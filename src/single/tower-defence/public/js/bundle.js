/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../node_modules/victor/index.js":
/*!*************************************************************************!*\
  !*** D:/workspace/self_github/game-server/node_modules/victor/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = Victor;\n\n/**\n * # Victor - A JavaScript 2D vector class with methods for common vector operations\n */\n\n/**\n * Constructor. Will also work without the `new` keyword\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = Victor(42, 1337);\n *\n * @param {Number} x Value of the x axis\n * @param {Number} y Value of the y axis\n * @return {Victor}\n * @api public\n */\nfunction Victor (x, y) {\n\tif (!(this instanceof Victor)) {\n\t\treturn new Victor(x, y);\n\t}\n\n\t/**\n\t * The X axis\n\t *\n\t * ### Examples:\n\t *     var vec = new Victor.fromArray(42, 21);\n\t *\n\t *     vec.x;\n\t *     // => 42\n\t *\n\t * @api public\n\t */\n\tthis.x = x || 0;\n\n\t/**\n\t * The Y axis\n\t *\n\t * ### Examples:\n\t *     var vec = new Victor.fromArray(42, 21);\n\t *\n\t *     vec.y;\n\t *     // => 21\n\t *\n\t * @api public\n\t */\n\tthis.y = y || 0;\n};\n\n/**\n * # Static\n */\n\n/**\n * Creates a new instance from an array\n *\n * ### Examples:\n *     var vec = Victor.fromArray([42, 21]);\n *\n *     vec.toString();\n *     // => x:42, y:21\n *\n * @name Victor.fromArray\n * @param {Array} array Array with the x and y values at index 0 and 1 respectively\n * @return {Victor} The new instance\n * @api public\n */\nVictor.fromArray = function (arr) {\n\treturn new Victor(arr[0] || 0, arr[1] || 0);\n};\n\n/**\n * Creates a new instance from an object\n *\n * ### Examples:\n *     var vec = Victor.fromObject({ x: 42, y: 21 });\n *\n *     vec.toString();\n *     // => x:42, y:21\n *\n * @name Victor.fromObject\n * @param {Object} obj Object with the values for x and y\n * @return {Victor} The new instance\n * @api public\n */\nVictor.fromObject = function (obj) {\n\treturn new Victor(obj.x || 0, obj.y || 0);\n};\n\n/**\n * # Manipulation\n *\n * These functions are chainable.\n */\n\n/**\n * Adds another vector's X axis to this one\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.addX(vec2);\n *     vec1.toString();\n *     // => x:30, y:10\n *\n * @param {Victor} vector The other vector you want to add to this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.addX = function (vec) {\n\tthis.x += vec.x;\n\treturn this;\n};\n\n/**\n * Adds another vector's Y axis to this one\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.addY(vec2);\n *     vec1.toString();\n *     // => x:10, y:40\n *\n * @param {Victor} vector The other vector you want to add to this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.addY = function (vec) {\n\tthis.y += vec.y;\n\treturn this;\n};\n\n/**\n * Adds another vector to this one\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.add(vec2);\n *     vec1.toString();\n *     // => x:30, y:40\n *\n * @param {Victor} vector The other vector you want to add to this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.add = function (vec) {\n\tthis.x += vec.x;\n\tthis.y += vec.y;\n\treturn this;\n};\n\n/**\n * Adds the given scalar to both vector axis\n *\n * ### Examples:\n *     var vec = new Victor(1, 2);\n *\n *     vec.addScalar(2);\n *     vec.toString();\n *     // => x: 3, y: 4\n *\n * @param {Number} scalar The scalar to add\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.addScalar = function (scalar) {\n\tthis.x += scalar;\n\tthis.y += scalar;\n\treturn this;\n};\n\n/**\n * Adds the given scalar to the X axis\n *\n * ### Examples:\n *     var vec = new Victor(1, 2);\n *\n *     vec.addScalarX(2);\n *     vec.toString();\n *     // => x: 3, y: 2\n *\n * @param {Number} scalar The scalar to add\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.addScalarX = function (scalar) {\n\tthis.x += scalar;\n\treturn this;\n};\n\n/**\n * Adds the given scalar to the Y axis\n *\n * ### Examples:\n *     var vec = new Victor(1, 2);\n *\n *     vec.addScalarY(2);\n *     vec.toString();\n *     // => x: 1, y: 4\n *\n * @param {Number} scalar The scalar to add\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.addScalarY = function (scalar) {\n\tthis.y += scalar;\n\treturn this;\n};\n\n/**\n * Subtracts the X axis of another vector from this one\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.subtractX(vec2);\n *     vec1.toString();\n *     // => x:80, y:50\n *\n * @param {Victor} vector The other vector you want subtract from this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtractX = function (vec) {\n\tthis.x -= vec.x;\n\treturn this;\n};\n\n/**\n * Subtracts the Y axis of another vector from this one\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.subtractY(vec2);\n *     vec1.toString();\n *     // => x:100, y:20\n *\n * @param {Victor} vector The other vector you want subtract from this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtractY = function (vec) {\n\tthis.y -= vec.y;\n\treturn this;\n};\n\n/**\n * Subtracts another vector from this one\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(20, 30);\n *\n *     vec1.subtract(vec2);\n *     vec1.toString();\n *     // => x:80, y:20\n *\n * @param {Victor} vector The other vector you want subtract from this one\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtract = function (vec) {\n\tthis.x -= vec.x;\n\tthis.y -= vec.y;\n\treturn this;\n};\n\n/**\n * Subtracts the given scalar from both axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 200);\n *\n *     vec.subtractScalar(20);\n *     vec.toString();\n *     // => x: 80, y: 180\n *\n * @param {Number} scalar The scalar to subtract\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtractScalar = function (scalar) {\n\tthis.x -= scalar;\n\tthis.y -= scalar;\n\treturn this;\n};\n\n/**\n * Subtracts the given scalar from the X axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 200);\n *\n *     vec.subtractScalarX(20);\n *     vec.toString();\n *     // => x: 80, y: 200\n *\n * @param {Number} scalar The scalar to subtract\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtractScalarX = function (scalar) {\n\tthis.x -= scalar;\n\treturn this;\n};\n\n/**\n * Subtracts the given scalar from the Y axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 200);\n *\n *     vec.subtractScalarY(20);\n *     vec.toString();\n *     // => x: 100, y: 180\n *\n * @param {Number} scalar The scalar to subtract\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.subtractScalarY = function (scalar) {\n\tthis.y -= scalar;\n\treturn this;\n};\n\n/**\n * Divides the X axis by the x component of given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(2, 0);\n *\n *     vec.divideX(vec2);\n *     vec.toString();\n *     // => x:50, y:50\n *\n * @param {Victor} vector The other vector you want divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divideX = function (vector) {\n\tthis.x /= vector.x;\n\treturn this;\n};\n\n/**\n * Divides the Y axis by the y component of given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(0, 2);\n *\n *     vec.divideY(vec2);\n *     vec.toString();\n *     // => x:100, y:25\n *\n * @param {Victor} vector The other vector you want divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divideY = function (vector) {\n\tthis.y /= vector.y;\n\treturn this;\n};\n\n/**\n * Divides both vector axis by a axis values of given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(2, 2);\n *\n *     vec.divide(vec2);\n *     vec.toString();\n *     // => x:50, y:25\n *\n * @param {Victor} vector The vector to divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divide = function (vector) {\n\tthis.x /= vector.x;\n\tthis.y /= vector.y;\n\treturn this;\n};\n\n/**\n * Divides both vector axis by the given scalar value\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.divideScalar(2);\n *     vec.toString();\n *     // => x:50, y:25\n *\n * @param {Number} The scalar to divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divideScalar = function (scalar) {\n\tif (scalar !== 0) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t} else {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t}\n\n\treturn this;\n};\n\n/**\n * Divides the X axis by the given scalar value\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.divideScalarX(2);\n *     vec.toString();\n *     // => x:50, y:50\n *\n * @param {Number} The scalar to divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divideScalarX = function (scalar) {\n\tif (scalar !== 0) {\n\t\tthis.x /= scalar;\n\t} else {\n\t\tthis.x = 0;\n\t}\n\treturn this;\n};\n\n/**\n * Divides the Y axis by the given scalar value\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.divideScalarY(2);\n *     vec.toString();\n *     // => x:100, y:25\n *\n * @param {Number} The scalar to divide by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.divideScalarY = function (scalar) {\n\tif (scalar !== 0) {\n\t\tthis.y /= scalar;\n\t} else {\n\t\tthis.y = 0;\n\t}\n\treturn this;\n};\n\n/**\n * Inverts the X axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.invertX();\n *     vec.toString();\n *     // => x:-100, y:50\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.invertX = function () {\n\tthis.x *= -1;\n\treturn this;\n};\n\n/**\n * Inverts the Y axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.invertY();\n *     vec.toString();\n *     // => x:100, y:-50\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.invertY = function () {\n\tthis.y *= -1;\n\treturn this;\n};\n\n/**\n * Inverts both axis\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.invert();\n *     vec.toString();\n *     // => x:-100, y:-50\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.invert = function () {\n\tthis.invertX();\n\tthis.invertY();\n\treturn this;\n};\n\n/**\n * Multiplies the X axis by X component of given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(2, 0);\n *\n *     vec.multiplyX(vec2);\n *     vec.toString();\n *     // => x:200, y:50\n *\n * @param {Victor} vector The vector to multiply the axis with\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiplyX = function (vector) {\n\tthis.x *= vector.x;\n\treturn this;\n};\n\n/**\n * Multiplies the Y axis by Y component of given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(0, 2);\n *\n *     vec.multiplyX(vec2);\n *     vec.toString();\n *     // => x:100, y:100\n *\n * @param {Victor} vector The vector to multiply the axis with\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiplyY = function (vector) {\n\tthis.y *= vector.y;\n\treturn this;\n};\n\n/**\n * Multiplies both vector axis by values from a given vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     var vec2 = new Victor(2, 2);\n *\n *     vec.multiply(vec2);\n *     vec.toString();\n *     // => x:200, y:100\n *\n * @param {Victor} vector The vector to multiply by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiply = function (vector) {\n\tthis.x *= vector.x;\n\tthis.y *= vector.y;\n\treturn this;\n};\n\n/**\n * Multiplies both vector axis by the given scalar value\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.multiplyScalar(2);\n *     vec.toString();\n *     // => x:200, y:100\n *\n * @param {Number} The scalar to multiply by\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiplyScalar = function (scalar) {\n\tthis.x *= scalar;\n\tthis.y *= scalar;\n\treturn this;\n};\n\n/**\n * Multiplies the X axis by the given scalar\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.multiplyScalarX(2);\n *     vec.toString();\n *     // => x:200, y:50\n *\n * @param {Number} The scalar to multiply the axis with\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiplyScalarX = function (scalar) {\n\tthis.x *= scalar;\n\treturn this;\n};\n\n/**\n * Multiplies the Y axis by the given scalar\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.multiplyScalarY(2);\n *     vec.toString();\n *     // => x:100, y:100\n *\n * @param {Number} The scalar to multiply the axis with\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.multiplyScalarY = function (scalar) {\n\tthis.y *= scalar;\n\treturn this;\n};\n\n/**\n * Normalize\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.normalize = function () {\n\tvar length = this.length();\n\n\tif (length === 0) {\n\t\tthis.x = 1;\n\t\tthis.y = 0;\n\t} else {\n\t\tthis.divide(Victor(length, length));\n\t}\n\treturn this;\n};\n\nVictor.prototype.norm = Victor.prototype.normalize;\n\n/**\n * If the absolute vector axis is greater than `max`, multiplies the axis by `factor`\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.limit(80, 0.9);\n *     vec.toString();\n *     // => x:90, y:50\n *\n * @param {Number} max The maximum value for both x and y axis\n * @param {Number} factor Factor by which the axis are to be multiplied with\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.limit = function (max, factor) {\n\tif (Math.abs(this.x) > max){ this.x *= factor; }\n\tif (Math.abs(this.y) > max){ this.y *= factor; }\n\treturn this;\n};\n\n/**\n * Randomizes both vector axis with a value between 2 vectors\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.randomize(new Victor(50, 60), new Victor(70, 80`));\n *     vec.toString();\n *     // => x:67, y:73\n *\n * @param {Victor} topLeft first vector\n * @param {Victor} bottomRight second vector\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.randomize = function (topLeft, bottomRight) {\n\tthis.randomizeX(topLeft, bottomRight);\n\tthis.randomizeY(topLeft, bottomRight);\n\n\treturn this;\n};\n\n/**\n * Randomizes the y axis with a value between 2 vectors\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.randomizeX(new Victor(50, 60), new Victor(70, 80`));\n *     vec.toString();\n *     // => x:55, y:50\n *\n * @param {Victor} topLeft first vector\n * @param {Victor} bottomRight second vector\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.randomizeX = function (topLeft, bottomRight) {\n\tvar min = Math.min(topLeft.x, bottomRight.x);\n\tvar max = Math.max(topLeft.x, bottomRight.x);\n\tthis.x = random(min, max);\n\treturn this;\n};\n\n/**\n * Randomizes the y axis with a value between 2 vectors\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.randomizeY(new Victor(50, 60), new Victor(70, 80`));\n *     vec.toString();\n *     // => x:100, y:66\n *\n * @param {Victor} topLeft first vector\n * @param {Victor} bottomRight second vector\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.randomizeY = function (topLeft, bottomRight) {\n\tvar min = Math.min(topLeft.y, bottomRight.y);\n\tvar max = Math.max(topLeft.y, bottomRight.y);\n\tthis.y = random(min, max);\n\treturn this;\n};\n\n/**\n * Randomly randomizes either axis between 2 vectors\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.randomizeAny(new Victor(50, 60), new Victor(70, 80));\n *     vec.toString();\n *     // => x:100, y:77\n *\n * @param {Victor} topLeft first vector\n * @param {Victor} bottomRight second vector\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.randomizeAny = function (topLeft, bottomRight) {\n\tif (!! Math.round(Math.random())) {\n\t\tthis.randomizeX(topLeft, bottomRight);\n\t} else {\n\t\tthis.randomizeY(topLeft, bottomRight);\n\t}\n\treturn this;\n};\n\n/**\n * Rounds both axis to an integer value\n *\n * ### Examples:\n *     var vec = new Victor(100.2, 50.9);\n *\n *     vec.unfloat();\n *     vec.toString();\n *     // => x:100, y:51\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.unfloat = function () {\n\tthis.x = Math.round(this.x);\n\tthis.y = Math.round(this.y);\n\treturn this;\n};\n\n/**\n * Rounds both axis to a certain precision\n *\n * ### Examples:\n *     var vec = new Victor(100.2, 50.9);\n *\n *     vec.unfloat();\n *     vec.toString();\n *     // => x:100, y:51\n *\n * @param {Number} Precision (default: 8)\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.toFixed = function (precision) {\n\tif (typeof precision === 'undefined') { precision = 8; }\n\tthis.x = this.x.toFixed(precision);\n\tthis.y = this.y.toFixed(precision);\n\treturn this;\n};\n\n/**\n * Performs a linear blend / interpolation of the X axis towards another vector\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 100);\n *     var vec2 = new Victor(200, 200);\n *\n *     vec1.mixX(vec2, 0.5);\n *     vec.toString();\n *     // => x:150, y:100\n *\n * @param {Victor} vector The other vector\n * @param {Number} amount The blend amount (optional, default: 0.5)\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.mixX = function (vec, amount) {\n\tif (typeof amount === 'undefined') {\n\t\tamount = 0.5;\n\t}\n\n\tthis.x = (1 - amount) * this.x + amount * vec.x;\n\treturn this;\n};\n\n/**\n * Performs a linear blend / interpolation of the Y axis towards another vector\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 100);\n *     var vec2 = new Victor(200, 200);\n *\n *     vec1.mixY(vec2, 0.5);\n *     vec.toString();\n *     // => x:100, y:150\n *\n * @param {Victor} vector The other vector\n * @param {Number} amount The blend amount (optional, default: 0.5)\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.mixY = function (vec, amount) {\n\tif (typeof amount === 'undefined') {\n\t\tamount = 0.5;\n\t}\n\n\tthis.y = (1 - amount) * this.y + amount * vec.y;\n\treturn this;\n};\n\n/**\n * Performs a linear blend / interpolation towards another vector\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 100);\n *     var vec2 = new Victor(200, 200);\n *\n *     vec1.mix(vec2, 0.5);\n *     vec.toString();\n *     // => x:150, y:150\n *\n * @param {Victor} vector The other vector\n * @param {Number} amount The blend amount (optional, default: 0.5)\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.mix = function (vec, amount) {\n\tthis.mixX(vec, amount);\n\tthis.mixY(vec, amount);\n\treturn this;\n};\n\n/**\n * # Products\n */\n\n/**\n * Creates a clone of this vector\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = vec1.clone();\n *\n *     vec2.toString();\n *     // => x:10, y:10\n *\n * @return {Victor} A clone of the vector\n * @api public\n */\nVictor.prototype.clone = function () {\n\treturn new Victor(this.x, this.y);\n};\n\n/**\n * Copies another vector's X component in to its own\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 20);\n *     var vec2 = vec1.copyX(vec1);\n *\n *     vec2.toString();\n *     // => x:20, y:10\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.copyX = function (vec) {\n\tthis.x = vec.x;\n\treturn this;\n};\n\n/**\n * Copies another vector's Y component in to its own\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 20);\n *     var vec2 = vec1.copyY(vec1);\n *\n *     vec2.toString();\n *     // => x:10, y:20\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.copyY = function (vec) {\n\tthis.y = vec.y;\n\treturn this;\n};\n\n/**\n * Copies another vector's X and Y components in to its own\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *     var vec2 = new Victor(20, 20);\n *     var vec2 = vec1.copy(vec1);\n *\n *     vec2.toString();\n *     // => x:20, y:20\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.copy = function (vec) {\n\tthis.copyX(vec);\n\tthis.copyY(vec);\n\treturn this;\n};\n\n/**\n * Sets the vector to zero (0,0)\n *\n * ### Examples:\n *     var vec1 = new Victor(10, 10);\n *\t\t var1.zero();\n *     vec1.toString();\n *     // => x:0, y:0\n *\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.zero = function () {\n\tthis.x = this.y = 0;\n\treturn this;\n};\n\n/**\n * Calculates the dot product of this vector and another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.dot(vec2);\n *     // => 23000\n *\n * @param {Victor} vector The second vector\n * @return {Number} Dot product\n * @api public\n */\nVictor.prototype.dot = function (vec2) {\n\treturn this.x * vec2.x + this.y * vec2.y;\n};\n\nVictor.prototype.cross = function (vec2) {\n\treturn (this.x * vec2.y ) - (this.y * vec2.x );\n};\n\n/**\n * Projects a vector onto another vector, setting itself to the result.\n *\n * ### Examples:\n *     var vec = new Victor(100, 0);\n *     var vec2 = new Victor(100, 100);\n *\n *     vec.projectOnto(vec2);\n *     vec.toString();\n *     // => x:50, y:50\n *\n * @param {Victor} vector The other vector you want to project this vector onto\n * @return {Victor} `this` for chaining capabilities\n * @api public\n */\nVictor.prototype.projectOnto = function (vec2) {\n    var coeff = ( (this.x * vec2.x)+(this.y * vec2.y) ) / ((vec2.x*vec2.x)+(vec2.y*vec2.y));\n    this.x = coeff * vec2.x;\n    this.y = coeff * vec2.y;\n    return this;\n};\n\n\nVictor.prototype.horizontalAngle = function () {\n\treturn Math.atan2(this.y, this.x);\n};\n\nVictor.prototype.horizontalAngleDeg = function () {\n\treturn radian2degrees(this.horizontalAngle());\n};\n\nVictor.prototype.verticalAngle = function () {\n\treturn Math.atan2(this.x, this.y);\n};\n\nVictor.prototype.verticalAngleDeg = function () {\n\treturn radian2degrees(this.verticalAngle());\n};\n\nVictor.prototype.angle = Victor.prototype.horizontalAngle;\nVictor.prototype.angleDeg = Victor.prototype.horizontalAngleDeg;\nVictor.prototype.direction = Victor.prototype.horizontalAngle;\n\nVictor.prototype.rotate = function (angle) {\n\tvar nx = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n\tvar ny = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n\tthis.x = nx;\n\tthis.y = ny;\n\n\treturn this;\n};\n\nVictor.prototype.rotateDeg = function (angle) {\n\tangle = degrees2radian(angle);\n\treturn this.rotate(angle);\n};\n\nVictor.prototype.rotateTo = function(rotation) {\n\treturn this.rotate(rotation-this.angle());\n};\n\nVictor.prototype.rotateToDeg = function(rotation) {\n\trotation = degrees2radian(rotation);\n\treturn this.rotateTo(rotation);\n};\n\nVictor.prototype.rotateBy = function (rotation) {\n\tvar angle = this.angle() + rotation;\n\n\treturn this.rotate(angle);\n};\n\nVictor.prototype.rotateByDeg = function (rotation) {\n\trotation = degrees2radian(rotation);\n\treturn this.rotateBy(rotation);\n};\n\n/**\n * Calculates the distance of the X axis between this vector and another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.distanceX(vec2);\n *     // => -100\n *\n * @param {Victor} vector The second vector\n * @return {Number} Distance\n * @api public\n */\nVictor.prototype.distanceX = function (vec) {\n\treturn this.x - vec.x;\n};\n\n/**\n * Same as `distanceX()` but always returns an absolute number\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.absDistanceX(vec2);\n *     // => 100\n *\n * @param {Victor} vector The second vector\n * @return {Number} Absolute distance\n * @api public\n */\nVictor.prototype.absDistanceX = function (vec) {\n\treturn Math.abs(this.distanceX(vec));\n};\n\n/**\n * Calculates the distance of the Y axis between this vector and another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.distanceY(vec2);\n *     // => -10\n *\n * @param {Victor} vector The second vector\n * @return {Number} Distance\n * @api public\n */\nVictor.prototype.distanceY = function (vec) {\n\treturn this.y - vec.y;\n};\n\n/**\n * Same as `distanceY()` but always returns an absolute number\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.distanceY(vec2);\n *     // => 10\n *\n * @param {Victor} vector The second vector\n * @return {Number} Absolute distance\n * @api public\n */\nVictor.prototype.absDistanceY = function (vec) {\n\treturn Math.abs(this.distanceY(vec));\n};\n\n/**\n * Calculates the euclidean distance between this vector and another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.distance(vec2);\n *     // => 100.4987562112089\n *\n * @param {Victor} vector The second vector\n * @return {Number} Distance\n * @api public\n */\nVictor.prototype.distance = function (vec) {\n\treturn Math.sqrt(this.distanceSq(vec));\n};\n\n/**\n * Calculates the squared euclidean distance between this vector and another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(200, 60);\n *\n *     vec1.distanceSq(vec2);\n *     // => 10100\n *\n * @param {Victor} vector The second vector\n * @return {Number} Distance\n * @api public\n */\nVictor.prototype.distanceSq = function (vec) {\n\tvar dx = this.distanceX(vec),\n\t\tdy = this.distanceY(vec);\n\n\treturn dx * dx + dy * dy;\n};\n\n/**\n * Calculates the length or magnitude of the vector\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.length();\n *     // => 111.80339887498948\n *\n * @return {Number} Length / Magnitude\n * @api public\n */\nVictor.prototype.length = function () {\n\treturn Math.sqrt(this.lengthSq());\n};\n\n/**\n * Squared length / magnitude\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *\n *     vec.lengthSq();\n *     // => 12500\n *\n * @return {Number} Length / Magnitude\n * @api public\n */\nVictor.prototype.lengthSq = function () {\n\treturn this.x * this.x + this.y * this.y;\n};\n\nVictor.prototype.magnitude = Victor.prototype.length;\n\n/**\n * Returns a true if vector is (0, 0)\n *\n * ### Examples:\n *     var vec = new Victor(100, 50);\n *     vec.zero();\n *\n *     // => true\n *\n * @return {Boolean}\n * @api public\n */\nVictor.prototype.isZero = function() {\n\treturn this.x === 0 && this.y === 0;\n};\n\n/**\n * Returns a true if this vector is the same as another\n *\n * ### Examples:\n *     var vec1 = new Victor(100, 50);\n *     var vec2 = new Victor(100, 50);\n *     vec1.isEqualTo(vec2);\n *\n *     // => true\n *\n * @return {Boolean}\n * @api public\n */\nVictor.prototype.isEqualTo = function(vec2) {\n\treturn this.x === vec2.x && this.y === vec2.y;\n};\n\n/**\n * # Utility Methods\n */\n\n/**\n * Returns an string representation of the vector\n *\n * ### Examples:\n *     var vec = new Victor(10, 20);\n *\n *     vec.toString();\n *     // => x:10, y:20\n *\n * @return {String}\n * @api public\n */\nVictor.prototype.toString = function () {\n\treturn 'x:' + this.x + ', y:' + this.y;\n};\n\n/**\n * Returns an array representation of the vector\n *\n * ### Examples:\n *     var vec = new Victor(10, 20);\n *\n *     vec.toArray();\n *     // => [10, 20]\n *\n * @return {Array}\n * @api public\n */\nVictor.prototype.toArray = function () {\n\treturn [ this.x, this.y ];\n};\n\n/**\n * Returns an object representation of the vector\n *\n * ### Examples:\n *     var vec = new Victor(10, 20);\n *\n *     vec.toObject();\n *     // => { x: 10, y: 20 }\n *\n * @return {Object}\n * @api public\n */\nVictor.prototype.toObject = function () {\n\treturn { x: this.x, y: this.y };\n};\n\n\nvar degrees = 180 / Math.PI;\n\nfunction random (min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction radian2degrees (rad) {\n\treturn rad * degrees;\n}\n\nfunction degrees2radian (deg) {\n\treturn deg / degrees;\n}\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/node_modules/victor/index.js?");

/***/ }),

/***/ "../../library/CollisionDetection.js":
/*!******************************************************************************!*\
  !*** D:/workspace/self_github/game-server/src/library/CollisionDetection.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class CollisionDetection {\r\n  static CircleRectColliding (circle, rect) {\r\n    var distX = Math.abs(circle.x - rect.x - rect.width / 2)\r\n    var distY = Math.abs(circle.y - rect.y - rect.height / 2)\r\n\r\n    if (distX > (rect.width / 2 + circle.radius)) { return false }\r\n    if (distY > (rect.height / 2 + circle.radius)) { return false }\r\n\r\n    if (distX <= (rect.width / 2)) { return true }\r\n    if (distY <= (rect.height / 2)) { return true }\r\n\r\n    var dx = distX - rect.width / 2\r\n    var dy = distY - rect.height / 2\r\n    return (dx * dx + dy * dy <= (circle.radius * circle.radius))\r\n  }\r\n  static RectRectColliding (rect1, rect2) {\r\n    if (rect1.x < rect2.x + rect2.width &&\r\n      rect1.x + rect1.width > rect2.x &&\r\n      rect1.y < rect2.y + rect2.height &&\r\n      rect1.height + rect1.y > rect2.y) {\r\n      // collision detected!\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n  static RectPointColliding (rect, point) {\r\n    if (rect.x <= point.x &&\r\n      rect.x + rect.width >= point.x &&\r\n      rect.y <= point.y &&\r\n      rect.height + rect.y >= point.y) {\r\n      // collision detected!\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n  static RectRectAngle (rect1, rect2) {\r\n    let r1 = {\r\n      hw: (rect1.width || 0) / 2, // half width\r\n      hh: (rect1.height || 0) / 2 // half height\r\n    }\r\n    let r2 = {\r\n      hw: (rect2.width || 0) / 2,\r\n      hh: (rect2.height || 0) / 2\r\n    }\r\n    var rect1_center = {\r\n      x: rect1.x + r1.hw,\r\n      y: rect1.y + r1.hh\r\n    }\r\n    var rect2_center = {\r\n      x: rect2.x + r2.hw,\r\n      y: rect2.y + r2.hh\r\n    }\r\n    return this.getAngle(rect1_center, rect2_center)\r\n  }\r\n  /**\r\n   * two rect distance\r\n   *\r\n   * @param      {object}  rect1   The rectangle 1\r\n   * @param      {object}  rect2   The rectangle 2\r\n   * @return     {number}  distance of two rect, if negative that's means two rect center distance(already touch each other)\r\n   */\r\n  static RectRectDistance (rect1, rect2) {\r\n    let r1 = {\r\n      hw: (rect1.width || 0) / 2, // half width\r\n      hh: (rect1.height || 0) / 2 // half height\r\n    }\r\n    let r2 = {\r\n      hw: (rect2.width || 0) / 2,\r\n      hh: (rect2.height || 0) / 2\r\n    }\r\n    var rect1_center = {\r\n      x: rect1.x + r1.hw,\r\n      y: rect1.y + r1.hh\r\n    }\r\n    var rect2_center = {\r\n      x: rect2.x + r2.hw,\r\n      y: rect2.y + r2.hh\r\n    }\r\n    // direct distance\r\n    var distance = Math.sqrt(Math.pow(rect2.x - rect1.x, 2) + Math.pow(rect2.y - rect1.y, 2))\r\n\r\n    let hpi = Math.PI / 2\r\n    var rect1_angle = this.getAngle(rect1, rect1_center) % hpi\r\n    var rect2_angle = this.getAngle(rect2, rect2_center) % hpi\r\n    // if from center to other's angle (0~90)\r\n    // < rect2_angle\r\n    // will go through the height side\r\n\r\n    let go_through_angle = this.getAngle(rect2_center, rect1_center)\r\n    // 0, 90, 180, 270\r\n    if (go_through_angle % Math.PI === 0) {\r\n      distance -= r1.hw + r2.hw\r\n    } else if (go_through_angle % hpi === 0) {\r\n      distance -= r1.hh + r2.hh\r\n    } else {\r\n      go_through_angle %= hpi\r\n      let\r\n        dx = Math.cos(go_through_angle),\r\n        dy = Math.sin(go_through_angle)\r\n      // no area through\r\n      if (rect1_angle !== 0) {\r\n        if (go_through_angle < rect1_angle) {\r\n          // go through the rect1 height side\r\n          distance -= r1.hw / dx\r\n        } else {\r\n          // go through the rect1 width side\r\n          distance -= r1.hh / dy\r\n        }\r\n      }\r\n      // no area through\r\n      if (rect2_angle !== 0) {\r\n        if (go_through_angle < rect2_angle) {\r\n          // go through the rect2 height side\r\n          distance -= r2.hw / dx\r\n        } else {\r\n          // go through the rect2 width side\r\n          distance -= r2.hh / dy\r\n        }\r\n      }\r\n    }\r\n    if (distance <= 0) {\r\n      // touch!! return two center distance.\r\n      return -Math.sqrt(Math.pow(rect2_center.x - rect1_center.x, 2) + Math.pow(rect2_center.y - rect1_center.y, 2))\r\n    }\r\n\r\n    return distance\r\n  }\r\n  static getAngle (p1, p2) {\r\n    var angle = Math.atan2(p2.y - p1.y, p2.x - p1.x)\r\n    if (angle < 0) angle += Math.PI * 2\r\n    return angle\r\n  }\r\n  static CircleRectDistance (circle, rect) {\r\n    var circle_center = {\r\n      x: circle.x + Math.cos(Math.PI / 2) * circle.radius,\r\n      y: circle.y + Math.cos(Math.PI / 2) * circle.radius\r\n    }\r\n    var rect_center = {\r\n      x: rect.x + rect.width / 2,\r\n      y: rect.y + rect.height / 2\r\n    }\r\n    // direct distance\r\n    var distance = Math.pow(Math.sqrt(rect.x - circle.x) + Math.sqrt(rect.y - circle.y), 2)\r\n\r\n    var rect_angle = this.getAngle(rect_center, rect)\r\n    // if from center to other's angle (0~90)\r\n    // < rect_angle\r\n    // will go through the height side\r\n\r\n    var go_through_angle = this.getAngle(circle_center, rect_center)\r\n    if (go_through_angle < rect_angle) {\r\n      // go through the height side\r\n      distance -= rect.width / 2 / Math.cos(go_through_angle)\r\n    } else {\r\n      // go through the width side\r\n      distance -= rect.height / 2 / Math.sin(go_through_angle)\r\n    }\r\n    distance -= circle.radius\r\n\r\n    return distance\r\n  }\r\n}\r\n\r\nmodule.exports = CollisionDetection\r\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/src/library/CollisionDetection.js?");

/***/ }),

/***/ "../../library/EasingFunctions.js":
/*!***************************************************************************!*\
  !*** D:/workspace/self_github/game-server/src/library/EasingFunctions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class EasingFunctions {\r\n  static easeOutQuad (t, b, c, d) {\r\n    t /= d\r\n    return -c * t * (t - 2) + b\r\n  }\r\n}\r\n\r\nmodule.exports = EasingFunctions\r\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/src/library/EasingFunctions.js?");

/***/ }),

/***/ "../../library/Guid.js":
/*!****************************************************************!*\
  !*** D:/workspace/self_github/game-server/src/library/Guid.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Guid {\r\n  static gen (namespace = '') {\r\n    function s4 () {\r\n      return Math.floor((1 + Math.random()) * 0x10000)\r\n        .toString(16)\r\n        .substring(1)\r\n    }\r\n    return namespace + s4() + s4() + '-' + s4() + '-' + s4() + '-' +\r\n      s4() + '-' + s4() + s4() + s4()\r\n  }\r\n}\r\n\r\nmodule.exports = Guid\r\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/src/library/Guid.js?");

/***/ }),

/***/ "../../library/SocketCommand.js":
/*!*************************************************************************!*\
  !*** D:/workspace/self_github/game-server/src/library/SocketCommand.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class SocketCommand {\r\n  constructor (namespace) {\r\n    this.socket = io(namespace)\r\n    this.queue = []\r\n  }\r\n  add (eventName, callback) {\r\n    var command = this\r\n    command.socket.on(eventName, function () {\r\n      command.queue.push({\r\n        eventName: 'on ' + eventName,\r\n        f: () => {\r\n          // let callback has socket.id\r\n          callback.apply(command.socket, arguments)\r\n        }\r\n      })\r\n    })\r\n  }\r\n  emit (eventName, data) {\r\n    var command = this\r\n    command.queue.push({\r\n      eventName: 'emit ' + eventName,\r\n      f: () => {\r\n        command.socket.emit(eventName, data)\r\n      }\r\n    })\r\n  }\r\n  executeAll () {\r\n    // message queue\r\n    for (var i = this.queue.length - 1; i >= 0; --i) {\r\n      let task = this.queue[i]\r\n      if (!task.executeTime) {\r\n        task.f()\r\n        task.executeTime = new Date()\r\n      } else {\r\n        if (task.executeTime.getTime() + 1000 * 10 < (new Date()).getTime()) {\r\n          this.queue.splice(i, 1) // Remove even numbers\r\n        }\r\n      }\r\n    }\r\n  }\r\n  getList () {\r\n    return this.queue\r\n  }\r\n}\r\n\r\nmodule.exports = SocketCommand\r\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/src/library/SocketCommand.js?");

/***/ }),

/***/ "../../library/Vector.js":
/*!******************************************************************!*\
  !*** D:/workspace/self_github/game-server/src/library/Vector.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Victor = __webpack_require__(/*! victor */ \"../../../node_modules/victor/index.js\")\r\n\r\nif (!Victor.fromRadians) {\r\n  Victor.fromRadians = (radians, radius) => {\r\n    return new Victor(\r\n      radius * Math.cos(radians),\r\n      radius * Math.sin(radians)\r\n    )\r\n  }\r\n}\r\n\r\nmodule.exports = Victor\r\n\n\n//# sourceURL=webpack:///D:/workspace/self_github/game-server/src/library/Vector.js?");

/***/ }),

/***/ "./src/class/Buff.js":
/*!***************************!*\
  !*** ./src/class/Buff.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ./ball */ \"./src/class/ball.js\")\r\n\r\nclass Buff extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      name: 'Ice',\r\n      width: 64,\r\n      height: 64,\r\n      duration: 1,\r\n      lifetime: 0,\r\n      image: 'effect/bolt03'\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  effect (other) {\r\n    other.mass *= 2\r\n    this.other = other\r\n  }\r\n  step (dt) {\r\n    this.lifetime += dt\r\n    let center = this.other.center\r\n    this.setCenter(center.x, center.y)\r\n    if (this.lifetime > this.duration) {\r\n      this.other.mass /= 2\r\n      this.other.removeBuff(this)\r\n    }\r\n  }\r\n  render () {\r\n    super.renderImage.apply(this, arguments)\r\n  }\r\n}\r\n\r\nmodule.exports = Buff\r\n\n\n//# sourceURL=webpack:///./src/class/Buff.js?");

/***/ }),

/***/ "./src/class/Floor.js":
/*!****************************!*\
  !*** ./src/class/Floor.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Graphic = __webpack_require__(/*! ./Graphic */ \"./src/class/Graphic.js\")\r\n\r\nclass Floor extends Graphic {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 32,\r\n      height: 32\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  render () {\r\n    switch (this.mapCode) {\r\n      case 0:\r\n        this.image = 'dc-dngn/gateways/dngn_portal'\r\n        break\r\n      case 1:\r\n        this.image = 'dc-dngn/floor/grass/grass1'\r\n        break\r\n      case 2:\r\n        this.image = 'dc-dngn/floor/grass/grass_full'\r\n        break\r\n      case 8:\r\n        this.image = 'dc-dngn/water/dngn_shoals_shallow_water1'\r\n        break\r\n      case 9:\r\n        this.image = 'dc-dngn/dngn_trap_teleport'\r\n        break\r\n    }\r\n    super.renderImage.apply(this, arguments)\r\n  }\r\n  canBuildOn () {\r\n    switch (this.mapCode) {\r\n      case 1:\r\n        return true\r\n      default:\r\n        return false\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Floor\r\n\n\n//# sourceURL=webpack:///./src/class/Floor.js?");

/***/ }),

/***/ "./src/class/Graphic.js":
/*!******************************!*\
  !*** ./src/class/Graphic.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CollisionDetection = __webpack_require__(/*! ../../../../library/CollisionDetection */ \"../../library/CollisionDetection.js\")\r\nconst EasingFunctions = __webpack_require__(/*! ../../../../library/EasingFunctions */ \"../../library/EasingFunctions.js\")\r\nconst Vector = __webpack_require__(/*! ../../../../library/Vector */ \"../../library/Vector.js\")\r\n\r\nlet listeners = new WeakMap()\r\n\r\nclass Graphic {\r\n  constructor (options) {\r\n    const defaults = {\r\n      x: 0,\r\n      y: 0,\r\n      width: 32,\r\n      height: 32,\r\n      color: '#00f'\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    for (const key in populated) {\r\n      if (populated.hasOwnProperty(key)) {\r\n        this[key] = populated[key]\r\n      }\r\n    }\r\n    listeners.set(this, [])\r\n  }\r\n  trigger (eventName, ...args) {\r\n    let selfEvent = this['on' + eventName.charAt(0).toUpperCase() + eventName.slice(1)]\r\n    let selfEventProp = true\r\n    if (typeof selfEvent === 'function') {\r\n      selfEventProp = selfEvent.apply(this, args) !== false\r\n    }\r\n    let events = listeners.get(this)\r\n    if (!events[eventName]) {\r\n      return selfEventProp\r\n    }\r\n    // if self or other stop prop, then stop\r\n    return selfEventProp && !events[eventName].some(event => event.apply(this, args) === false)\r\n  }\r\n  on (eventName, callback) {\r\n    if (typeof callback !== 'function') {\r\n      throw 'callback must be a function'\r\n    }\r\n    let events = listeners.get(this)\r\n    if (!events[eventName]) {\r\n      events[eventName] = []\r\n    }\r\n    events[eventName].push(callback)\r\n    listeners.set(this, events)\r\n    return this\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    app.layer\r\n      .fillStyle(this.color)\r\n      .fillRect(this.x + deltaPoint.x, this.y + deltaPoint.y, this.width, this.height)\r\n  }\r\n  renderImage (app, deltaPoint = { x: 0, y: 0 }) {\r\n    app.layer.drawImage(app.images[this.image], this.x + deltaPoint.x, this.y + deltaPoint.y, this.width, this.height)\r\n  }\r\n  renderAtlas (app, deltaPoint = { x: 0, y: 0 }) {\r\n    let atlas = app.atlases[this.atlases]\r\n    let current = (app.lifetime % 2 / 2) * atlas.frames.length | 0\r\n\r\n    app.layer\r\n      .save()\r\n      .setTransform(1, 0, 0, 1, this.x + deltaPoint.x, this.y + deltaPoint.y)\r\n      .drawAtlasFrame(atlas, current, 0, 0)\r\n      .restore()\r\n  }\r\n  get center () {\r\n    return {\r\n      x: this.x + (this.width || 0) / 2,\r\n      y: this.y + (this.height || 0) / 2\r\n    }\r\n  }\r\n  setCenter (x, y) {\r\n    this.x = x - (this.width || 0) / 2\r\n    this.y = y - (this.height || 0) / 2\r\n  }\r\n  step (dt) {\r\n    this.trigger('step', dt)\r\n  }\r\n  static isInRect (point, rect) {\r\n    return rect.x <= point.x &&\r\n      rect.y <= point.y &&\r\n      rect.x + rect.width >= point.x &&\r\n      rect.y + rect.height >= point.y\r\n  }\r\n}\r\n\r\nmodule.exports = Graphic\r\n\n\n//# sourceURL=webpack:///./src/class/Graphic.js?");

/***/ }),

/***/ "./src/class/Group.js":
/*!****************************!*\
  !*** ./src/class/Group.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Group {\r\n  constructor (...args) {\r\n    this.x = 0\r\n    this.y = 0\r\n    this.set = new Set()\r\n  }\r\n  add (...args) {\r\n    return this.set.add(...args)\r\n  }\r\n  delete (...args) {\r\n    return this.set.delete(...args)\r\n  }\r\n  has (...args) {\r\n    return this.set.has(...args)\r\n  }\r\n  get size () {\r\n    return this.set.size\r\n  }\r\n  forEach (callback) {\r\n    return this.set.forEach(callback)\r\n  }\r\n  some (callback) {\r\n    let some = false\r\n    this.set.forEach((...args) => {\r\n      if (some) {\r\n        return\r\n      }\r\n      if (callback(...args)) {\r\n        some = true\r\n      }\r\n    })\r\n    return some\r\n  }\r\n  step (dt) {\r\n    this.set.forEach(graphic => graphic.step(dt))\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    let delta = {\r\n      x: this.x + deltaPoint.x,\r\n      y: this.y + deltaPoint.y\r\n    }\r\n    this.set.forEach(graphic => graphic.render(app, delta))\r\n  }\r\n}\r\n\r\nmodule.exports = Group\r\n\n\n//# sourceURL=webpack:///./src/class/Group.js?");

/***/ }),

/***/ "./src/class/LevelData.js":
/*!********************************!*\
  !*** ./src/class/LevelData.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("class LevelData {\r\n  constructor () {\r\n  }\r\n  setLevel (level) {\r\n    this.level = level\r\n    this.round = 0\r\n    this.data = __webpack_require__(/*! ../levels/level1.json */ \"./src/levels/level1.json\")\r\n  }\r\n  get enemy_path () {\r\n    return this.data.enemy_path\r\n  }\r\n  get map () {\r\n    return this.data.map\r\n  }\r\n  get roundData () {\r\n    return this.data.round[this.round - 1]\r\n  }\r\n  get nextRoundData () {\r\n    return this.data.round[this.round]\r\n  }\r\n  nextRound () {\r\n    if (this.hasNextRound()) {\r\n      this.round++\r\n    }\r\n  }\r\n  hasNextRound () {\r\n    return this.round < this.data.round.length\r\n  }\r\n}\r\n\r\nmodule.exports = LevelData\r\n\n\n//# sourceURL=webpack:///./src/class/LevelData.js?");

/***/ }),

/***/ "./src/class/ball.js":
/*!***************************!*\
  !*** ./src/class/ball.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Graphic = __webpack_require__(/*! ./Graphic */ \"./src/class/Graphic.js\")\r\nconst CollisionDetection = __webpack_require__(/*! ../../../../library/CollisionDetection */ \"../../library/CollisionDetection.js\")\r\nconst EasingFunctions = __webpack_require__(/*! ../../../../library/EasingFunctions */ \"../../library/EasingFunctions.js\")\r\nconst Vector = __webpack_require__(/*! ../../../../library/Vector */ \"../../library/Vector.js\")\r\n\r\nclass Ball extends Graphic {\r\n  constructor (options) {\r\n    const defaults = {\r\n      directRadians: 0,\r\n      hp: 1,\r\n      hpMax: 1,\r\n      damage: 0,\r\n      defence: 0,\r\n      attackDistance: 0,\r\n      mass: 1,\r\n      punchForce: 0,\r\n      friction: 0,\r\n      buffs: []\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n    this.clazz = this.constructor.name\r\n\r\n    if (this.accelerate) {\r\n      this.accelerate = new Vector(this.accelerate.x, this.accelerate.y)\r\n    } else {\r\n      this.accelerate = new Vector()\r\n    }\r\n  }\r\n  addBuff (buff) {\r\n    if (this.buffs[buff.name]) {\r\n      return\r\n    }\r\n    buff.effect(this)\r\n    this.buffs[buff.name] = buff\r\n  }\r\n  removeBuff (buff) {\r\n    delete this.buffs[buff.name]\r\n  }\r\n  onStep (dt) {\r\n    Object.values(this.buffs).forEach(buff => buff.step(dt))\r\n    // friction\r\n    if (this.friction !== 0) {\r\n      let friction = this.accelerate.clone().rotate(Math.PI).multiply(new Vector(this.friction, this.friction))\r\n      this.accelerate.add(friction)\r\n    }\r\n    // dont move\r\n    this.x += this.accelerate.x\r\n    this.y += this.accelerate.y\r\n  }\r\n  renderBuff () {\r\n    Object.values(this.buffs).forEach(buff => buff.render.apply(buff, arguments))\r\n  }\r\n  render () {\r\n    this.renderBuff.apply(this, arguments)\r\n    super.render.apply(this, arguments)\r\n  }\r\n  renderImage () {\r\n    this.renderBuff.apply(this, arguments)\r\n    super.renderImage.apply(this, arguments)\r\n  }\r\n  renderAtlas () {\r\n    this.renderBuff.apply(this, arguments)\r\n    super.renderAtlas.apply(this, arguments)\r\n  }\r\n  /**\r\n   * Gets the damage.\r\n   *\r\n   * @param      {number}  damage  The damage\r\n   * @return     {boolean}  still alive\r\n   */\r\n  getDamage (damage, dt) {\r\n    this.hp -= Math.max(damage * dt - this.defence, 0)\r\n    var isAlive = this.isAlive()\r\n    if (!isAlive) {\r\n      this.die()\r\n    }\r\n    return isAlive\r\n  }\r\n  isAlive () {\r\n    return this.hp > 0\r\n  }\r\n  attack (other, dt = 1) {\r\n    var isHitted = this.canAttack(other)\r\n    if (isHitted) {\r\n      other.getAttack(this, dt)\r\n      this.getDamage(other.defence, dt)\r\n    }\r\n    return isHitted\r\n  }\r\n  getAttack (other, dt) {\r\n    let isAlive = this.getDamage(other.damage, dt)\r\n    if (isAlive) {\r\n      // punch\r\n      other.punch(this)\r\n    }\r\n  }\r\n  punch (other) {\r\n    let angle = CollisionDetection.RectRectAngle(other, this)\r\n    other.accelerate.add(\r\n      Vector.fromRadians(angle, -this.punchForce)\r\n    )\r\n  }\r\n  // can attack other\r\n  canAttack (other) {\r\n    if (this === other) {\r\n      return false\r\n    }\r\n    return CollisionDetection.RectRectDistance(this, other) <= this.attackDistance\r\n  }\r\n  die () {\r\n    this.trigger('die')\r\n  }\r\n}\r\n\r\nmodule.exports = Ball\r\n\n\n//# sourceURL=webpack:///./src/class/ball.js?");

/***/ }),

/***/ "./src/class/cursor.js":
/*!*****************************!*\
  !*** ./src/class/cursor.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ./ball */ \"./src/class/ball.js\")\r\n\r\nclass Cursor extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 40,\r\n      height: 40,\r\n      image: 'cursor',\r\n      canBuildHere: true\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  getSelectedBuild () {\r\n    return this.build\r\n  }\r\n  clearSelected () {\r\n    delete this.build\r\n    this.canBuildHere = true\r\n  }\r\n  setSelectedBuild (build) {\r\n    this.build = build\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    if (this.build) {\r\n      this.build.setCenter(this.x, this.y)\r\n      this.build.render(app, deltaPoint)\r\n      if (!this.canBuildHere) {\r\n        let lineRadius = 40\r\n        app.layer\r\n          .save()\r\n          .lineWidth(5)\r\n          .strokeStyle('#F00')\r\n          .strokeLine(this.x - lineRadius, this.y - lineRadius, this.x + lineRadius, this.y + lineRadius)\r\n          .strokeLine(this.x + lineRadius, this.y - lineRadius, this.x - lineRadius, this.y + lineRadius)\r\n          .restore()\r\n      }\r\n    } else {\r\n      super.renderImage(app, deltaPoint)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Cursor\r\n\n\n//# sourceURL=webpack:///./src/class/cursor.js?");

/***/ }),

/***/ "./src/class/enemy/Enemy.js":
/*!**********************************!*\
  !*** ./src/class/enemy/Enemy.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ../ball */ \"./src/class/ball.js\")\r\nconst EasingFunctions = __webpack_require__(/*! ../../../../../library/EasingFunctions */ \"../../library/EasingFunctions.js\")\r\nconst Vector = __webpack_require__(/*! ../../../../../library/Vector */ \"../../library/Vector.js\")\r\n\r\nclass Enemy extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      nextPathIndex: 1,\r\n      reward: 0,\r\n      score: 0,\r\n      escapeFine: 0,\r\n      scale: 1,\r\n      hideHpBar: false\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  onStep (dt) {\r\n    let\r\n      from = Vector.fromObject(this.path[this.nextPathIndex - 1]),\r\n      to = Vector.fromObject(this.path[this.nextPathIndex])\r\n    if (Vector.fromObject(this).subtract(from).length() > to.clone().subtract(from).length()) {\r\n      this.nextPathIndex++\r\n      if (!this.path[this.nextPathIndex]) {\r\n        this.trigger('atEndPoint', dt)\r\n        return\r\n      }\r\n    }\r\n    // acceleration\r\n    this.accelerate = to.clone().subtract(from)\r\n    let length = this.accelerate.length()\r\n    this.accelerate.multiply(new Vector(1 / this.mass / length, 1 / this.mass / length))\r\n\r\n    super.onStep.apply(this, arguments)\r\n  }\r\n  render () {\r\n    this.renderAtlas.apply(this, arguments)\r\n  }\r\n  renderAtlas (app, deltaPoint = { x: 0, y: 0 }) {\r\n    let isFaceToLeft = Math.abs(this.directRadians) < Math.PI / 2\r\n    let x = this.x + deltaPoint.x + (isFaceToLeft ? 0 : this.width) + this.width * (1 - this.scale)\r\n    let y = this.y + deltaPoint.y + this.height * (1 - this.scale)\r\n\r\n    super.renderBuff.apply(this, arguments)\r\n\r\n    this.renderRun(app, x, y, isFaceToLeft)\r\n    if (!this.hideHpBar) {\r\n      this.renderHp(app, deltaPoint)\r\n    }\r\n  }\r\n  renderHp (app, deltaPoint) {\r\n    let\r\n      hpX = this.x + deltaPoint.x,\r\n      hpY = this.y - 20 + deltaPoint.y,\r\n      hpW = 50,\r\n      hpH = 10\r\n    app.layer\r\n      .fillStyle('#000')\r\n      .fillRect(hpX, hpY, hpW, hpH)\r\n      .fillStyle('#F00')\r\n      .fillRect(hpX, hpY, hpW * (this.hp / this.hpMax), hpH)\r\n  }\r\n  renderRun (app, x, y, isFaceToLeft) {\r\n    let atlas = app.atlases[this.atlases]\r\n    // 3, 4, 5, 6\r\n    let length = this.accelerate.length()\r\n    let current = ((app.lifetime * length * 2) % 2 / 2) * 4 | 0\r\n    current += 3\r\n\r\n    app.layer\r\n      .save()\r\n      .setTransform(this.scale, 0, 0, this.scale, x, y)\r\n      .scale(isFaceToLeft ? 1 : -1, 1)\r\n      .drawAtlasFrame(atlas, current, 0, 0)\r\n      .restore()\r\n  }\r\n  setPath (path) {\r\n    this.path = path\r\n  }\r\n}\r\n\r\nmodule.exports = Enemy\r\n\n\n//# sourceURL=webpack:///./src/class/enemy/Enemy.js?");

/***/ }),

/***/ "./src/class/enemy/EnemyFactory.js":
/*!*****************************************!*\
  !*** ./src/class/enemy/EnemyFactory.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Guid = __webpack_require__(/*! ../../../../../library/Guid */ \"../../library/Guid.js\")\r\nconst EnemyTypes = [\r\n  __webpack_require__(/*! ./Sorlosheet */ \"./src/class/enemy/Sorlosheet.js\"),\r\n  __webpack_require__(/*! ./SorlosheetSuper */ \"./src/class/enemy/SorlosheetSuper.js\")\r\n]\r\n\r\nclass EnemyFactory {\r\n  static newEnemy (options) {\r\n    const defaults = {\r\n      id: Guid.gen('enemy'),\r\n      type: 0\r\n    }\r\n    options.hpMax = options.hp\r\n    const populated = Object.assign(defaults, options)\r\n\r\n    let type = EnemyTypes[populated.type]\r\n    return new type(options)\r\n  }\r\n}\r\n\r\nmodule.exports = EnemyFactory\r\n\n\n//# sourceURL=webpack:///./src/class/enemy/EnemyFactory.js?");

/***/ }),

/***/ "./src/class/enemy/Sorlosheet.js":
/*!***************************************!*\
  !*** ./src/class/enemy/Sorlosheet.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Enemy = __webpack_require__(/*! ./Enemy */ \"./src/class/enemy/Enemy.js\")\r\n\r\nclass Sorlosheet extends Enemy {\r\n  constructor (options) {\r\n    const defaults = {\r\n      hp: 10,\r\n      hpMax: 10,\r\n      width: 72,\r\n      height: 72,\r\n      atlases: 'sorlosheet',\r\n      defence: 0,\r\n      mass: 0.5,\r\n      reward: 10,\r\n      score: 1,\r\n      escapeFine: 1\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n}\r\n\r\nmodule.exports = Sorlosheet\r\n\n\n//# sourceURL=webpack:///./src/class/enemy/Sorlosheet.js?");

/***/ }),

/***/ "./src/class/enemy/SorlosheetSuper.js":
/*!********************************************!*\
  !*** ./src/class/enemy/SorlosheetSuper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Enemy = __webpack_require__(/*! ./Enemy */ \"./src/class/enemy/Enemy.js\")\r\n\r\nclass SorlosheetSuper extends Enemy {\r\n  constructor (options) {\r\n    const defaults = {\r\n      hp: 10,\r\n      hpMax: 10,\r\n      width: 72,\r\n      height: 72,\r\n      atlases: 'sorlosheet_super',\r\n      defence: 0,\r\n      mass: 0.5,\r\n      reward: 10,\r\n      score: 1,\r\n      escapeFine: 1\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n}\r\n\r\nmodule.exports = SorlosheetSuper\r\n\n\n//# sourceURL=webpack:///./src/class/enemy/SorlosheetSuper.js?");

/***/ }),

/***/ "./src/class/gamemap.js":
/*!******************************!*\
  !*** ./src/class/gamemap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ./ball */ \"./src/class/ball.js\")\r\nconst Floor = __webpack_require__(/*! ./Floor */ \"./src/class/Floor.js\")\r\nconst TowerFire = __webpack_require__(/*! ./tower/TowerFire */ \"./src/class/tower/TowerFire.js\")\r\nconst TowerIce = __webpack_require__(/*! ./tower/TowerIce */ \"./src/class/tower/TowerIce.js\")\r\nconst EnemyFactory = __webpack_require__(/*! ./enemy/EnemyFactory */ \"./src/class/enemy/EnemyFactory.js\")\r\nconst TowerUI = __webpack_require__(/*! ../gui/TowerUI */ \"./src/gui/TowerUI.js\")\r\nconst Group = __webpack_require__(/*! ./Group */ \"./src/class/Group.js\")\r\n\r\nconst Guid = __webpack_require__(/*! ../../../../library/Guid */ \"../../library/Guid.js\")\r\nconst Vector = __webpack_require__(/*! ../../../../library/Vector */ \"../../library/Vector.js\")\r\nconst CollisionDetection = __webpack_require__(/*! ../../../../library/CollisionDetection */ \"../../library/CollisionDetection.js\")\r\n\r\nclass GameMap extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      x: 0,\r\n      y: 0,\r\n      map: new Group(),\r\n      tower: new Group(),\r\n      projectile: new Group(),\r\n      objects: new Group(),\r\n      towerUI: new TowerUI()\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n    this.group = new Group()\r\n    this.group.add(this.map)\r\n    this.group.add(this.tower)\r\n    this.group.add(this.projectile)\r\n    this.group.add(this.objects)\r\n    this.group.add(this.towerUI)\r\n  }\r\n  get pointOfStart () {\r\n    return this.levelData.enemy_path[0]\r\n  }\r\n  get pointOfEnd () {\r\n    return this.levelData.enemy_path[this.levelData.enemy_path.length - 1]\r\n  }\r\n  init (levelData) {\r\n    this.levelData = levelData\r\n    this.levelData.map.forEach((e, i) => {\r\n      e.forEach((mapCode, j) => {\r\n        this.map.add(new Floor({\r\n          mapCode: mapCode,\r\n          width: 64,\r\n          height: 64,\r\n          x: i * 64,\r\n          y: j * 64\r\n        }))\r\n      })\r\n    })\r\n  }\r\n  step (dt) {\r\n    if (!this.isRunning) {\r\n      this.projectile.step(dt)\r\n      return\r\n    }\r\n    super.step(dt)\r\n    this.group.step(dt)\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    var hpX = app.width - 250\r\n    var hpDy = 20\r\n    var hpH = 30\r\n    var hpHInit = 20\r\n    var hpHCurrent = hpHInit + hpH + hpDy\r\n\r\n    this.group.x = deltaPoint.x\r\n    this.group.y = deltaPoint.y\r\n    this.group.render(app)\r\n  }\r\n  /** collision with other tower & road */\r\n  tryBuildTower (tower) {\r\n    // clear towerUI\r\n    this.towerUI.inactive()\r\n    // collision with other tower\r\n    for (const other of Object.values(this.tower.set)) {\r\n      let distance = CollisionDetection.RectRectDistance(tower, other)\r\n      if (distance <= 0) {\r\n        return false\r\n      }\r\n    }\r\n    let collisionWithOtherTower = this.tower.some(other => {\r\n      return CollisionDetection.RectRectDistance(tower, other) <= 0\r\n    })\r\n    if (collisionWithOtherTower) {\r\n      return false\r\n    }\r\n    let canBuildOn = true\r\n    let inMap = false\r\n    this.map.forEach(map => {\r\n      let distance = CollisionDetection.RectRectDistance(tower, map)\r\n      if (distance <= 0) {\r\n        inMap = true\r\n        canBuildOn &= map.canBuildOn()\r\n      }\r\n    })\r\n    return inMap && canBuildOn\r\n  }\r\n  addTower (tower) {\r\n    if (!this.tryBuildTower(tower)) {\r\n      return false\r\n    }\r\n    tower.on('step', (dt) => {\r\n      this.attackInRange(tower, dt)\r\n    }).on('attack', (other, dt) => {\r\n      let projectile = tower.throwObject\r\n      projectile.goto(other)\r\n      projectile.on('atEndPoint', () => {\r\n        this.attackOnTouch(tower, projectile)\r\n        this.projectile.delete(projectile)\r\n      })\r\n      this.addProjectile(projectile)\r\n    })\r\n    this.tower.add(tower)\r\n    return true\r\n  }\r\n  removeTower (tower) {\r\n    this.tower.delete(tower)\r\n  }\r\n  addProjectile (projectile) {\r\n    this.projectile.add(projectile)\r\n  }\r\n  addObject (object) {\r\n    if (this.objects.has(object)) {\r\n      this.objects.delete(object)\r\n    }\r\n    this.objects.add(object)\r\n    object.on('die', () => {\r\n      this.objects.delete(object)\r\n    })\r\n  }\r\n  // remove object\r\n  remove (object) {\r\n    this.objects.delete(object)\r\n  }\r\n  magicAttack (object) {\r\n    var center = object.center\r\n    var fire = new Fire({\r\n      id: Guid.gen('fire'),\r\n      x: object.x,\r\n      y: center.y,\r\n      accelerate: Vector.fromRadians(object.directRadians, 10)\r\n    })\r\n    this.addObject(fire)\r\n    fire.on('step', () => {\r\n      this.attackOnTouch(object, fire)\r\n    })\r\n    return fire\r\n  }\r\n  attackInRange (tower, dt) {\r\n    this.objects.forEach(object => {\r\n      tower.attack(object, dt)\r\n    })\r\n  }\r\n  attackOnTouch (attacker, weapon) {\r\n    this.objects.some(object => {\r\n      if (object === attacker) {\r\n        return false\r\n      }\r\n      weapon.attack(object)\r\n      if (!weapon.isAlive()) {\r\n        return true\r\n      }\r\n      return false\r\n    })\r\n  }\r\n  attackRange (attacker) {\r\n    this.objects.forEach(object => attacker.attack(object))\r\n  }\r\n  roundStart () {\r\n    if (this.isRunning) {\r\n      return\r\n    }\r\n    this.levelData.nextRound()\r\n    this.isRunning = true\r\n    let gamemap = this\r\n    let roundData = this.levelData.roundData\r\n    let enemy_data = Object.assign(roundData.enemy, {\r\n      x: this.pointOfStart.x,\r\n      y: this.pointOfStart.y\r\n    })\r\n    let enemy_count = roundData.count\r\n    this.timer = setInterval(() => {\r\n      if (enemy_count > 0) {\r\n        let enemy = EnemyFactory.newEnemy(enemy_data)\r\n        enemy.on('die', () => {\r\n          gamemap.trigger('enemyDie', enemy)\r\n        }).on('atEndPoint', () => {\r\n          // minus score\r\n          gamemap.trigger('enemyEscape', enemy)\r\n        }).setPath(this.levelData.enemy_path)\r\n        this.addObject(enemy)\r\n\r\n        enemy_count--\r\n      } else {\r\n        if (this.objects.size === 0) {\r\n          clearInterval(this.timer)\r\n          this.isRunning = false\r\n          gamemap.trigger('roundEnd')\r\n        } else {\r\n          console.log('monster running count: ', this.objects.size)\r\n        }\r\n      }\r\n    }, 1000)\r\n  }\r\n  nextRoundEnemy () {\r\n    let roundData = this.levelData.hasNextRound() ? this.levelData.nextRoundData : this.levelData.roundData\r\n    return EnemyFactory.newEnemy(roundData.enemy)\r\n  }\r\n  gameOver () {\r\n    clearInterval(this.timer)\r\n    this.isRunning = false\r\n    this.trigger('gameOver')\r\n  }\r\n\r\n  showTowerArea (isShow) {\r\n    this.tower.forEach(tower => {\r\n      tower.isShowArea = isShow\r\n    })\r\n  }\r\n\r\n  onMousedown (...args) {\r\n    args.unshift('mousedown')\r\n    let propagation\r\n    propagation = this.towerUI.trigger.apply(this.towerUI, args)\r\n    if (propagation === false) {\r\n      return false\r\n    }\r\n\r\n    this.towerUI.inactive()\r\n    propagation = this.tower.forEach(object => {\r\n      let propagation = object.trigger.apply(object, args)\r\n      if (object.isShowArea) {\r\n        this.towerUI.active(object)\r\n      }\r\n      return !propagation\r\n    })\r\n    return !propagation\r\n  }\r\n}\r\n\r\nmodule.exports = GameMap\r\n\n\n//# sourceURL=webpack:///./src/class/gamemap.js?");

/***/ }),

/***/ "./src/class/icon.js":
/*!***************************!*\
  !*** ./src/class/icon.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ./ball */ \"./src/class/ball.js\")\r\n\r\nclass Icon extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      color: '#60a030'\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n}\r\n\r\nmodule.exports = Icon\r\n\n\n//# sourceURL=webpack:///./src/class/icon.js?");

/***/ }),

/***/ "./src/class/tower/FireBolt.js":
/*!*************************************!*\
  !*** ./src/class/tower/FireBolt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ../ball */ \"./src/class/ball.js\")\r\nconst Vector = __webpack_require__(/*! ../../../../../library/Vector */ \"../../library/Vector.js\")\r\n\r\nclass FireBolt extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      image: 'fire_bolt',\r\n      width: 50 * 1,\r\n      height: 13 * 1,\r\n      attackDistance: 0,\r\n      mass: 0.1\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    this.renderImage(app, deltaPoint)\r\n  }\r\n  renderImage (app, deltaPoint = { x: 0, y: 0 }) {\r\n    app.layer\r\n      .save()\r\n      .setTransform(1, 0, 0, 1, this.x + deltaPoint.x, this.y + deltaPoint.y)\r\n      .rotate(this.accelerate.angle())\r\n      .drawImage(\r\n        app.images[this.image], -this.width / 2, -this.height / 2,\r\n        this.width,\r\n        this.height\r\n      )\r\n      .restore()\r\n  }\r\n  goto (other) {\r\n    this.from = Vector.fromObject(this)\r\n    this.to = Vector.fromObject(other.center)\r\n    // acceleration\r\n    this.accelerate = this.to.clone().subtract(this.from)\r\n    let length = this.accelerate.length()\r\n    this.accelerate.multiply(new Vector(1 / this.mass / length, 1 / this.mass / length))\r\n  }\r\n  onStep () {\r\n    if (Vector.fromObject(this).subtract(this.from).length() > this.to.clone().subtract(this.from).length()) {\r\n      this.x = this.to.x\r\n      this.y = this.to.y\r\n      this.trigger('atEndPoint')\r\n    }\r\n    super.onStep.apply(this, arguments)\r\n  }\r\n}\r\n\r\nmodule.exports = FireBolt\r\n\n\n//# sourceURL=webpack:///./src/class/tower/FireBolt.js?");

/***/ }),

/***/ "./src/class/tower/IceBolt.js":
/*!************************************!*\
  !*** ./src/class/tower/IceBolt.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const FireBolt = __webpack_require__(/*! ./FireBolt */ \"./src/class/tower/FireBolt.js\")\r\nconst Buff = __webpack_require__(/*! ../Buff */ \"./src/class/Buff.js\")\r\n\r\nclass IceBolt extends FireBolt {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 64,\r\n      height: 64,\r\n      attackDistance: 0,\r\n      mass: 0.1\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  goto (other) {\r\n    super.goto.apply(this, arguments)\r\n    this.setCenter(other.center)\r\n  }\r\n  attack (other, dt = 1) {\r\n    let isHitted = super.attack.apply(this, arguments)\r\n    if (isHitted) {\r\n      other.addBuff(new Buff())\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = IceBolt\r\n\n\n//# sourceURL=webpack:///./src/class/tower/IceBolt.js?");

/***/ }),

/***/ "./src/class/tower/Tower.js":
/*!**********************************!*\
  !*** ./src/class/tower/Tower.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ball = __webpack_require__(/*! ../ball */ \"./src/class/ball.js\")\r\nconst Guid = __webpack_require__(/*! ../../../../../library/Guid */ \"../../library/Guid.js\")\r\nconst Window = __webpack_require__(/*! ../../gui/Window */ \"./src/gui/Window.js\")\r\n\r\nclass Tower extends Ball {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 60,\r\n      height: 60,\r\n      damage: 10,\r\n      attackDistance: 300,\r\n      colddown: 1,\r\n      lifetime: 0,\r\n      preAttackTime: 0,\r\n      isShowArea: true,\r\n      level: 0\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  static get DAMAGE () {\r\n    return 'damage'\r\n  }\r\n  static get RADIUS () {\r\n    return 'radius'\r\n  }\r\n  static get COLDDOWN () {\r\n    return 'cd'\r\n  }\r\n  get cost () {\r\n    return 10\r\n  }\r\n  get sellIncome () {\r\n    return 10\r\n  }\r\n  onStep (dt) {\r\n    this.lifetime += dt\r\n    super.onStep.apply(this, arguments)\r\n  }\r\n  onAttack (other, dt = 1) {\r\n    this.preAttackTime = this.lifetime\r\n  }\r\n  attack (other, dt = 1) {\r\n    if (!this.isColddown(dt)) {\r\n      return\r\n    }\r\n    var isHitted = this.canAttack(other)\r\n    if (isHitted) {\r\n      this.trigger('attack', other, dt)\r\n      this.nextshot = 0\r\n    }\r\n    return isHitted\r\n  }\r\n  isColddown (dt) {\r\n    return this.nextshot < this.colddown\r\n  }\r\n  get throwObject () {\r\n    let center = this.center\r\n    return new this.projectileClass({\r\n      x: center.x,\r\n      y: center.y,\r\n      damage: this.damage,\r\n      id: Guid.gen(this.projectileClass)\r\n    })\r\n  }\r\n  onMousedown (point) {\r\n    if (point.button === 'left') {\r\n      if (Tower.isInRect(point, this)) {\r\n        this.isShowArea = true\r\n        return false\r\n      }\r\n    }\r\n    this.isShowArea = false\r\n  }\r\n  render (app, deltaPoint = { x: 0, y: 0 }) {\r\n    super.renderImage.apply(this, arguments)\r\n    if (this.isShowArea) {\r\n      this.renderAttackDistance(app, deltaPoint)\r\n    }\r\n  }\r\n  renderAttackDistance (app, deltaPoint) {\r\n    let center = this.center\r\n    var x = center.x + deltaPoint.x\r\n    var y = center.y + deltaPoint.y\r\n    app.layer\r\n      .fillStyle('rgba(255, 255, 255, 0.3)')\r\n      .fillCircle(x, y, this.attackDistance)\r\n  }\r\n  hasUpgradeOption () {\r\n    // subclass implements\r\n    return this.upgradeOptions.length > 0\r\n  }\r\n  get upgradeOptions () {\r\n    return []\r\n  }\r\n  upgrade () {\r\n    if (!this.hasUpgradeOption()) {\r\n      return\r\n    }\r\n    let option = this.upgradeOptions[0]\r\n    this.trigger('upgrade', option, () => {\r\n      option.attrs.forEach(attr => this.upgradeWithSpecificOption(attr.type, attr.value))\r\n      this.level++\r\n    })\r\n  }\r\n  upgradeWithSpecificOption (type, value) {\r\n    switch (type) {\r\n      case Tower.DAMAGE:\r\n        this.damage += value\r\n        break\r\n      case Tower.RADIUS:\r\n        this.attackDistance += value\r\n        break\r\n      case Tower.COLDDOWN:\r\n        this.colddown += value\r\n        break\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Tower\r\n\n\n//# sourceURL=webpack:///./src/class/tower/Tower.js?");

/***/ }),

/***/ "./src/class/tower/TowerFire.js":
/*!**************************************!*\
  !*** ./src/class/tower/TowerFire.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tower = __webpack_require__(/*! ./Tower */ \"./src/class/tower/Tower.js\")\r\nconst FireBolt = __webpack_require__(/*! ./FireBolt */ \"./src/class/tower/FireBolt.js\")\r\n\r\nconst upgradeOptions = [{\r\n  name: 'level 1',\r\n  cost: 10,\r\n  attrs: [{\r\n    type: Tower.DAMAGE,\r\n    value: 10\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.1\r\n  }]\r\n}, {\r\n  name: 'level 2',\r\n  cost: 30,\r\n  attrs: [{\r\n    type: Tower.DAMAGE,\r\n    value: 30\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.1\r\n  }]\r\n}, {\r\n  name: 'level 3',\r\n  cost: 200,\r\n  attrs: [{\r\n    type: Tower.DAMAGE,\r\n    value: 100\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.2\r\n  }]\r\n}, {\r\n  name: 'level 4',\r\n  cost: 200,\r\n  attrs: [{\r\n    type: Tower.DAMAGE,\r\n    value: 100\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.2\r\n  }]\r\n}, {\r\n  name: 'level 5',\r\n  cost: 200,\r\n  attrs: [{\r\n    type: Tower.DAMAGE,\r\n    value: 100\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.2\r\n  }]\r\n}]\r\n\r\nclass TowerFire extends Tower {\r\n  constructor (options) {\r\n    const defaults = {\r\n      image: 'dc-dngn/altars/dngn_altar_makhleb_flame1',\r\n      damage: 10,\r\n      attackDistance: 300,\r\n      colddown: 1\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  isColddown (dt) {\r\n    return this.lifetime - this.preAttackTime >= this.colddown\r\n  }\r\n  get cost () {\r\n    return 10\r\n  }\r\n  get sellIncome () {\r\n    return 10\r\n  }\r\n  get projectileClass () {\r\n    return FireBolt\r\n  }\r\n  get upgradeOptions () {\r\n    return upgradeOptions.slice(this.level)\r\n  }\r\n}\r\n\r\nmodule.exports = TowerFire\r\n\n\n//# sourceURL=webpack:///./src/class/tower/TowerFire.js?");

/***/ }),

/***/ "./src/class/tower/TowerIce.js":
/*!*************************************!*\
  !*** ./src/class/tower/TowerIce.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tower = __webpack_require__(/*! ./Tower */ \"./src/class/tower/Tower.js\")\r\nconst IceBolt = __webpack_require__(/*! ./IceBolt */ \"./src/class/tower/IceBolt.js\")\r\n\r\nconst upgradeOptions = [{\r\n  name: 'level 1',\r\n  cost: 30,\r\n  attrs: [{\r\n    type: Tower.RADIUS,\r\n    value: 50\r\n  }, {\r\n    type: Tower.DAMAGE,\r\n    value: 5\r\n  }]\r\n}, {\r\n  name: 'level 2',\r\n  cost: 30,\r\n  attrs: [{\r\n    type: Tower.RADIUS,\r\n    value: 50\r\n  }, {\r\n    type: Tower.DAMAGE,\r\n    value: 5\r\n  }]\r\n}, {\r\n  name: 'level 3',\r\n  cost: 30,\r\n  attrs: [{\r\n    type: Tower.COLDDOWN,\r\n    value: -0.2\r\n  }]\r\n}, {\r\n  name: 'level 4',\r\n  cost: 100,\r\n  attrs: [{\r\n    type: Tower.RADIUS,\r\n    value: 200\r\n  }, {\r\n    type: Tower.COLDDOWN,\r\n    value: -0.1\r\n  }, {\r\n    type: Tower.DAMAGE,\r\n    value: -10\r\n  }]\r\n}]\r\n\r\nclass TowerIce extends Tower {\r\n  constructor (options) {\r\n    const defaults = {\r\n      image: 'dc-dngn/altars/dngn_altar_sif_muna',\r\n      damage: 5,\r\n      attackDistance: 100,\r\n      colddown: 0.3\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  isColddown (dt) {\r\n    return this.lifetime % this.colddown <= dt\r\n  }\r\n  get cost () {\r\n    return 50\r\n  }\r\n  get sellIncome () {\r\n    return 50\r\n  }\r\n  get projectileClass () {\r\n    return IceBolt\r\n  }\r\n  get upgradeOptions () {\r\n    return upgradeOptions.slice(this.level)\r\n  }\r\n}\r\n\r\nmodule.exports = TowerIce\r\n\n\n//# sourceURL=webpack:///./src/class/tower/TowerIce.js?");

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const GameMap = __webpack_require__(/*! ./class/gamemap */ \"./src/class/gamemap.js\")\r\nconst TowerFire = __webpack_require__(/*! ./class/tower/TowerFire */ \"./src/class/tower/TowerFire.js\")\r\nconst TowerIce = __webpack_require__(/*! ./class/tower/TowerIce */ \"./src/class/tower/TowerIce.js\")\r\nconst Cursor = __webpack_require__(/*! ./class/cursor */ \"./src/class/cursor.js\")\r\nconst Icon = __webpack_require__(/*! ./class/icon */ \"./src/class/icon.js\")\r\nconst SocketCommand = __webpack_require__(/*! ../../../library/SocketCommand */ \"../../library/SocketCommand.js\")\r\nconst Guid = __webpack_require__(/*! ../../../library/Guid */ \"../../library/Guid.js\")\r\nconst LevelData = __webpack_require__(/*! ./class/LevelData */ \"./src/class/LevelData.js\")\r\n\r\nconst TechTree = __webpack_require__(/*! ./gui/TechTree */ \"./src/gui/TechTree.js\")\r\n\r\nconst GAME_NAME = '/tower-defence'\r\n\r\nvar ENGINE = {\r\n  Resource: {},\r\n  command: undefined,\r\n  isInit: false\r\n}\r\n\r\nENGINE.Game = {\r\n\r\n  wallet: {\r\n    balance: 100,\r\n    balanceReal: 100,\r\n    hold: 0\r\n  },\r\n\r\n  score: 0,\r\n  messageTip: 'press 1 or 2 select tower, then upgrade by click on it.',\r\n\r\n  create: function () {\r\n    let game = this\r\n    this.command = new SocketCommand(GAME_NAME)\r\n    this.command.add('set_map', function (map) {\r\n      if (!game.isInit) {\r\n        // game.isInit = true;\r\n        // game.gameMap = new GameMap(map);\r\n        // game.thomas = game.gameMap.getUser(this.id);\r\n      }\r\n    })\r\n    this.cursor = new Cursor()\r\n    this.towerList = [TowerFire, TowerIce]\r\n    this.techTree = new TechTree({\r\n      width: 1000\r\n    })\r\n  },\r\n\r\n  enter: function () {\r\n    var game = this\r\n    var app = this.app\r\n\r\n    app.scrollingBackground = new ScrollingBackground(app.images.background)\r\n\r\n    // ENGINE.Resource = app.music.play(\"music\", true);\r\n    ENGINE.enemies = []\r\n    ENGINE.bombs = []\r\n    ENGINE.items = []\r\n    ENGINE.users = []\r\n\r\n    this.levelData = new LevelData()\r\n    this.levelData.setLevel(1)\r\n\r\n    this.gameMap = new GameMap()\r\n    this.gameMap.init(this.levelData)\r\n    this.gameMap.on('enemyDie', enemy => {\r\n      this.wallet.balanceReal += enemy.reward\r\n      this.wallet.balance += enemy.reward\r\n      this.score += enemy.score\r\n    })\r\n    this.gameMap.on('enemyEscape', enemy => {\r\n      this.score -= enemy.escapeFine\r\n      this.gameMap.remove(enemy)\r\n      this.gameMap.gameOver()\r\n    })\r\n    this.gameMap.on('roundEnd', () => {\r\n      let timer, second = 5\r\n      timer = setInterval(() => {\r\n        second--\r\n        this.messageTip = 'Next Round will begin at ' + second + ' second later'\r\n        if (second <= 0) {\r\n          clearInterval(timer)\r\n          this.messageTip = ''\r\n          this.gameMap.roundStart()\r\n        }\r\n      }, 1000)\r\n    })\r\n    this.gameMap.on('gameOver', () => {\r\n      this.messageTip = 'game over, your score: ' + this.score\r\n    })\r\n    this.gameMap.roundStart()\r\n  },\r\n\r\n  step: function (dt) {\r\n    var center = this.app.center\r\n    // message queue\r\n    this.command.executeAll()\r\n\r\n    if (this.gameMap) {\r\n      this.gameMap.step(dt)\r\n    }\r\n  },\r\n\r\n  render: function (dt) {\r\n    var app = this.app\r\n    var hpX = app.width - 250\r\n    var hpDy = 20\r\n    var hpH = 30\r\n    var hpHCurrent = 200\r\n\r\n    app.layer.clear('#000')\r\n\r\n    if (!this.gameMap) {\r\n      return\r\n    }\r\n\r\n    this.oPoint = app.scrollingBackground.render(app, {x: 0, y: 200})\r\n\r\n    this.gameMap.render(app, this.oPoint)\r\n\r\n    // money\r\n    app.layer\r\n      .fillStyle('#000')\r\n      .fillRect(0, 0, 1500, 200)\r\n      .font('30px Verdana')\r\n      .fillStyle('#FFD700')\r\n      .fillText('$' + this.wallet.balanceReal.toFixed(2), 50, 50)\r\n      .fillStyle('#00D700')\r\n      .fillText('score: ' + this.score, 50, 100)\r\n      .fillStyle('#FFD700')\r\n      .fillText('Round ' + this.levelData.round, 350, 50)\r\n      .fillStyle('#FFD700')\r\n      .fillText(this.messageTip, 350, 100)\r\n\r\n    // next round info\r\n    let nextRoundData = this.levelData.hasNextRound() ? this.levelData.nextRoundData : this.levelData.roundData\r\n    let nextRoundEnemy = this.gameMap.nextRoundEnemy()\r\n    nextRoundEnemy.hideHpBar = true\r\n    nextRoundEnemy.x = 430\r\n    nextRoundEnemy.y = 120\r\n    app.layer.fillText('Next: ', 350, 150)\r\n    nextRoundEnemy.render(app)\r\n    app.layer\r\n      .fillStyle('#F00')\r\n      .fillText([\r\n        'hp: ' + nextRoundEnemy.hp,\r\n        'speed: ' + (1 / nextRoundEnemy.mass).toFixed(2),\r\n        'defence: ' + nextRoundEnemy.defence\r\n      ].join(', '), 500, 150)\r\n      .fillText(' x ' + nextRoundData.count, 490, 200)\r\n    // tower sample\r\n    let tower_sample = {\r\n      attackDistance: 0,\r\n      x: 50,\r\n      y: 100\r\n    }\r\n    this.towerList.forEach((towerClass, i) => {\r\n      let tower = new this.towerList[i](tower_sample)\r\n      let center = tower.center\r\n      tower.render(app)\r\n      app.layer\r\n        .fillStyle('#FFD700')\r\n        .fillText('$' + tower.cost, center.x - 30, tower_sample.y + tower.height + 30)\r\n      tower_sample.x += tower.width + 20\r\n    })\r\n\r\n    // gui\r\n    // this.techTree.render(app);\r\n\r\n    let queue = this.command.getList()\r\n    for (let i = queue.length - 1, max = Math.max(queue.length - 10, 0); i >= max; --i) {\r\n      app.layer\r\n        .font('40px Georgia')\r\n        .fillStyle(hpH + 'px #abc')\r\n        .fillText(queue[i].eventName, hpX, hpHCurrent)\r\n      hpHCurrent += hpH + hpDy\r\n    }\r\n\r\n    // mouse active\r\n    this.cursor.render(app)\r\n  },\r\n\r\n  keydown: function (data) {\r\n    var direct = 0b0000\r\n    switch (data.key) {\r\n      case 'a':\r\n      case 'left':\r\n        direct |= 0b1000\r\n        break\r\n      case 'd':\r\n      case 'right':\r\n        direct |= 0b0100\r\n        break\r\n      case 'w':\r\n      case 'up':\r\n        direct |= 0b0010\r\n        break\r\n      case 's':\r\n      case 'down':\r\n        direct |= 0b0001\r\n        break\r\n      case '1':\r\n      case '2':\r\n        this.selectBuild(data.key)\r\n        this.traceBuildLocation(this.cursor)\r\n        break\r\n    }\r\n  },\r\n\r\n  keyup: function (data) {\r\n    var direct = 0b1111\r\n    switch (data.key) {\r\n      case 'a':\r\n      case 'left':\r\n        direct &= 0b0111\r\n        break\r\n      case 'd':\r\n      case 'right':\r\n        direct &= 0b1011\r\n        break\r\n      case 'w':\r\n      case 'up':\r\n        direct &= 0b1101\r\n        break\r\n      case 's':\r\n      case 'down':\r\n        direct &= 0b1110\r\n        break\r\n    }\r\n  },\r\n\r\n  mousemove: function (data) {\r\n    // gui\r\n    this.techTree.trigger('mousemove', data)\r\n\r\n    this.traceBuildLocation(data)\r\n    this.cursor.x = data.x\r\n    this.cursor.y = data.y\r\n  },\r\n\r\n  mousedown: function (data) {\r\n    // gui\r\n    this.techTree.trigger('mousedown', data)\r\n    let gameMapOrigin = {\r\n      x: data.x - this.oPoint.x,\r\n      y: data.y - this.oPoint.y,\r\n      button: data.button\r\n    }\r\n    this.gameMap.trigger('mousedown', gameMapOrigin)\r\n\r\n    let\r\n      button = data.button,\r\n      build = this.cursor.getSelectedBuild()\r\n    if (!build) {\r\n      return\r\n    }\r\n    if (button === 'left') {\r\n      // create build\r\n      build.setCenter(this.cursor.x - this.oPoint.x, this.cursor.y - this.oPoint.y)\r\n      build.id = Guid.gen('tower')\r\n      let isSuccess = this.gameMap.addTower(build)\r\n      if (isSuccess) {\r\n        build.on('sell', () => {\r\n          console.log('selled', build)\r\n          this.wallet.balanceReal += build.sellIncome\r\n          this.wallet.balance += build.sellIncome\r\n          this.gameMap.removeTower(build)\r\n        }).on('upgrade', (option, upgradeFunc) => {\r\n          if (this.wallet.balanceReal < option.cost) {\r\n            this.messageTip = 'money not enough'\r\n            return\r\n          }\r\n          this.wallet.balanceReal -= option.cost\r\n          this.wallet.balance -= option.cost\r\n          upgradeFunc()\r\n        })\r\n        this.cursor.clearSelected()\r\n        this.wallet.balanceReal -= build.cost\r\n        this.gameMap.showTowerArea(false)\r\n      }\r\n    } else if (button === 'right') {\r\n      // cancel, return money back\r\n      this.cursor.clearSelected()\r\n      this.wallet.balance += build.cost\r\n      this.gameMap.showTowerArea(false)\r\n    }\r\n  },\r\n\r\n  mouseup: function (data) {\r\n    // gui\r\n    this.techTree.trigger('mouseup', data)\r\n  },\r\n\r\n  traceBuildLocation (data) {\r\n    let build = this.cursor.getSelectedBuild()\r\n    if (build) {\r\n      data.x = Math.floor(data.x / 64) * 64 + 31\r\n      data.y = Math.floor(data.y / 64) * 64 + 38\r\n      // try building\r\n      build.setCenter(data.x - this.oPoint.x, data.y - this.oPoint.y)\r\n      this.cursor.canBuildHere = this.gameMap.tryBuildTower(build)\r\n    }\r\n  },\r\n\r\n  selectBuild (index) {\r\n    index -= 1\r\n    let build = new this.towerList[index]()\r\n    if (this.wallet.balanceReal < build.cost) {\r\n      // has no more money\r\n      return\r\n    }\r\n    this.wallet.balance -= build.cost\r\n    this.cursor.setSelectedBuild(build)\r\n    this.gameMap.showTowerArea(true)\r\n  }\r\n\r\n}\r\nvar ScrollingBackground = function (image) {\r\n  var bw = image.width\r\n  var bh = image.height\r\n  var layer = {}\r\n  this.directRadians = Math.asin(-1)\r\n  this.faceDirectBits = 0b0000 // LRUD\r\n  this.dontMove = true\r\n\r\n  this.render = function (app, start = { x: 0, y: 0 }) {\r\n    let\r\n      w = app.width,\r\n      h = app.height,\r\n      x = 0 + start.x, // where the begin x\r\n      y = 0 + start.y, // where the begin y\r\n      dx = x % bw,\r\n      dy = y % bh,\r\n      nx = Math.ceil(w / bw) + 1,\r\n      ny = Math.ceil(h / bh) + 1,\r\n      backgrounds = []\r\n    for (var i = -1; i <= nx; i++) {\r\n      for (var j = -1; j <= ny; j++) {\r\n        backgrounds.push([\r\n          i * bw + dx,\r\n          j * bh + dy\r\n        ])\r\n      }\r\n    }\r\n    backgrounds.forEach(function (e) {\r\n      app.layer.drawImage(image, e[0], e[1])\r\n    })\r\n    return {\r\n      x: x,\r\n      y: y\r\n    }\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  constructor () {\r\n    this.queue = []\r\n  }\r\n  push (msg) {\r\n    this.queue.push(msg)\r\n  }\r\n  shift () {\r\n    return this.queue.shift()\r\n  }\r\n}\r\n\r\nmodule.exports = ENGINE\r\n\n\n//# sourceURL=webpack:///./src/engine.js?");

/***/ }),

/***/ "./src/gui/TechTree.js":
/*!*****************************!*\
  !*** ./src/gui/TechTree.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Window = __webpack_require__(/*! ./Window */ \"./src/gui/Window.js\")\r\n\r\nclass Tech {\r\n  constructor () {\r\n    this.data = {\r\n      level: 0,\r\n      isEnabled: false\r\n    }\r\n    this.parent = null\r\n    this.children = []\r\n  }\r\n  upgrade () {\r\n    this.data.level++\r\n  }\r\n  upgradeCost () {\r\n    return this.data.level * 30\r\n  }\r\n}\r\n\r\nclass Tree {\r\n  constructor (tech) {\r\n    this._root = tech\r\n  }\r\n}\r\n\r\nclass TechTree extends Window {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 500,\r\n      height: 1000,\r\n      backgroundColor: '#066'\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n    this.init()\r\n  }\r\n  init () {\r\n    // this.tree = new Tech();\r\n    // this.tree._root.children.push(new Tech());\r\n  }\r\n  renderExpend (app) {\r\n    super.renderExpend.apply(this, arguments)\r\n\r\n    let renderArea = this.renderArea\r\n    let iconSize = 50\r\n    app.layer\r\n      .fillStyle('#777')\r\n      .fillRect(renderArea.x, renderArea.y, iconSize, iconSize)\r\n      .lineWidth(5)\r\n      .strokeStyle('#FFF')\r\n      .strokeRect(renderArea.x, renderArea.y, iconSize, iconSize)\r\n  }\r\n}\r\n\r\nmodule.exports = TechTree\r\n\n\n//# sourceURL=webpack:///./src/gui/TechTree.js?");

/***/ }),

/***/ "./src/gui/TowerUI.js":
/*!****************************!*\
  !*** ./src/gui/TowerUI.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Window = __webpack_require__(/*! ./Window */ \"./src/gui/Window.js\")\r\n\r\nconst btnH = 30\r\n\r\nconst getNumber = (theNumber) => {\r\n  if (theNumber > 0) {\r\n    return '+' + theNumber\r\n  } else {\r\n    return theNumber.toString()\r\n  }\r\n}\r\n\r\nclass TowerUI extends Window {\r\n  constructor (options) {\r\n    const defaults = {\r\n      width: 300,\r\n      height: 400,\r\n      noExpendBtn: true,\r\n      backgroundColor: 'rgba(255, 255, 255, 0.5)',\r\n      strokeColor: 'rgba(255, 255, 255, 0)'\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  /* set UI info for tower */\r\n  active (tower) {\r\n    let center = tower.center\r\n    this.setCenter(center.x, center.y)\r\n    this.tower = tower\r\n  }\r\n  onMousedown (point) {\r\n    if (point.button !== 'left') {\r\n      return true\r\n    }\r\n    if (this.tower) {\r\n      return super.onMousedown(point)\r\n    }\r\n  }\r\n  inactive () {\r\n    delete this.tower\r\n  }\r\n  render (app, deltaPoint) {\r\n    if (!this.tower) {\r\n      return\r\n    }\r\n    this.deltaPoint = deltaPoint\r\n    super.render.apply(this, arguments)\r\n  }\r\n  renderWindow (app, deltaPoint) {\r\n    let tower = this.tower\r\n    this.renderTowerInfo(app, deltaPoint)\r\n    if (tower.hasUpgradeOption()) {\r\n      this.renderUpgrade(app, deltaPoint)\r\n    }\r\n    this.renderSellBtn(app, deltaPoint)\r\n  }\r\n  mousedownInWindow (point) {\r\n    // sell tower\r\n    if (TowerUI.isInRect(point, this.areaOfSellBtn)) {\r\n      this.tower.trigger('sell')\r\n      this.inactive()\r\n      return false\r\n    } else if (TowerUI.isInRect(point, this.areaOfUpgradeBtn)) {\r\n      this.tower.upgrade()\r\n    }\r\n  }\r\n  renderTowerInfo (app, deltaPoint) {\r\n    let areaOfTowerInfo = this.areaOfTowerInfo\r\n    areaOfTowerInfo.x += deltaPoint.x\r\n    areaOfTowerInfo.y += deltaPoint.y\r\n    let tower = this.tower\r\n    let x = areaOfTowerInfo.x\r\n    let currentY = areaOfTowerInfo.y\r\n    let textArray = [\r\n      'damage: ' + tower.damage.toFixed(2),\r\n      'radius: ' + tower.attackDistance.toFixed(2),\r\n      'cd: ' + tower.colddown.toFixed(2)\r\n    ]\r\n    textArray.forEach(text => {\r\n      app.layer\r\n        .fillStyle('rgba(0, 0, 0, 0.5)')\r\n        .fillRect(x, currentY, areaOfTowerInfo.width, btnH)\r\n        .font('30px Verdana')\r\n        .fillStyle('#FFD700')\r\n        .fillText(text, x, currentY += 30)\r\n    })\r\n  }\r\n  get areaOfTowerInfo () {\r\n    let renderArea = this.renderArea\r\n    return {\r\n      x: renderArea.x,\r\n      y: renderArea.y,\r\n      width: renderArea.width,\r\n      height: btnH * 3\r\n    }\r\n  }\r\n  renderUpgrade (app, deltaPoint) {\r\n    let areaOfUpgradeBtn = this.areaOfUpgradeBtn\r\n    areaOfUpgradeBtn.x += deltaPoint.x\r\n    areaOfUpgradeBtn.y += deltaPoint.y\r\n    let upgradeOptions = this.tower.upgradeOptions\r\n    let currentY = areaOfUpgradeBtn.y\r\n\r\n    // only show 3 upgrade item\r\n    upgradeOptions.slice(0, 3).forEach((option, index) => {\r\n      app.layer\r\n        .fillStyle('rgba(0, 0, 0, 0.5)')\r\n        .fillRect(areaOfUpgradeBtn.x, currentY, areaOfUpgradeBtn.width, areaOfUpgradeBtn.height)\r\n        .font('30px Verdana')\r\n        .fillStyle('#FFD700')\r\n        .fillText(' ' + option.name + '($' + option.cost + ')', areaOfUpgradeBtn.x, currentY + 30)\r\n      if (index === 0) {\r\n        option.attrs.forEach(attr => {\r\n          currentY += btnH\r\n          app.layer\r\n            .fillStyle('rgba(0, 0, 0, 0.5)')\r\n            .fillRect(areaOfUpgradeBtn.x, currentY, areaOfUpgradeBtn.width, areaOfUpgradeBtn.height)\r\n            .font('30px Verdana')\r\n            .fillStyle('#DDA700')\r\n            .fillText('  ' + getNumber(attr.value) + ' ' + attr.type, areaOfUpgradeBtn.x, currentY + 30)\r\n        })\r\n      } else {\r\n        // can NOT upgrade\r\n        app.layer\r\n          .fillStyle('rgba(0, 0, 0, 0.5)')\r\n          .fillRect(areaOfUpgradeBtn.x, currentY, areaOfUpgradeBtn.width, areaOfUpgradeBtn.height)\r\n      }\r\n      currentY += btnH\r\n    })\r\n  }\r\n  get areaOfUpgradeBtn () {\r\n    let areaOfTowerInfo = this.areaOfTowerInfo\r\n    return {\r\n      x: areaOfTowerInfo.x,\r\n      y: areaOfTowerInfo.y + areaOfTowerInfo.height + btnH / 2,\r\n      width: areaOfTowerInfo.width,\r\n      height: btnH\r\n    }\r\n  }\r\n  renderSellBtn (app, deltaPoint) {\r\n    let areaOfSellBtn = this.areaOfSellBtn\r\n    areaOfSellBtn.x += deltaPoint.x\r\n    areaOfSellBtn.y += deltaPoint.y\r\n    app.layer\r\n      .fillStyle('rgba(0, 0, 0, 0.5)')\r\n      .fillRect(areaOfSellBtn.x, areaOfSellBtn.y, areaOfSellBtn.width, areaOfSellBtn.height)\r\n      .font('30px Verdana')\r\n      .fillStyle('#FFD700')\r\n      .fillText('sell($' + this.tower.sellIncome.toFixed(0) + ')', areaOfSellBtn.x, areaOfSellBtn.y + 30)\r\n  }\r\n  get areaOfSellBtn () {\r\n    let renderArea = this.renderArea\r\n    return {\r\n      x: renderArea.x,\r\n      y: renderArea.y + renderArea.height - btnH,\r\n      width: renderArea.width,\r\n      height: btnH\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = TowerUI\r\n\n\n//# sourceURL=webpack:///./src/gui/TowerUI.js?");

/***/ }),

/***/ "./src/gui/Window.js":
/*!***************************!*\
  !*** ./src/gui/Window.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Graphic = __webpack_require__(/*! ../class/Graphic */ \"./src/class/Graphic.js\")\r\nlet defaults = {\r\n  btnSize: 20,\r\n  strokeWidth: 5\r\n}\r\n\r\nclass Window extends Graphic {\r\n  constructor (options) {\r\n    const defaults = {\r\n      backgroundColor: '#000',\r\n      barColor: '#005',\r\n      expendBtnColor: '#084',\r\n      strokeColor: '#FFF',\r\n      isExpend: true,\r\n      noExpendBtn: false\r\n    }\r\n    const populated = Object.assign(defaults, options)\r\n    super(populated)\r\n  }\r\n  get renderArea () {\r\n    let strokeWidth = defaults.strokeWidth\r\n    let btnSize = defaults.btnSize\r\n    return {\r\n      x: this.x + strokeWidth / 2,\r\n      y: this.y + btnSize + strokeWidth / 2,\r\n      width: this.width - strokeWidth,\r\n      height: this.height - btnSize - strokeWidth\r\n    }\r\n  }\r\n  onMousedown (point) {\r\n    let btnSize = defaults.btnSize\r\n    let isExpendBtn = Window.isInRect(point, {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: btnSize,\r\n      height: btnSize\r\n    })\r\n    let isDragBar = Window.isInRect(point, {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: this.width,\r\n      height: btnSize\r\n    })\r\n    let isInWindow = Window.isInRect(point, {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: this.width,\r\n      height: this.height\r\n    })\r\n    if (isExpendBtn) {\r\n      this.isExpend = !this.isExpend\r\n      return false\r\n    } else if (isDragBar) {\r\n      this.isDrag = true\r\n      this.dragPoint = {\r\n        x: point.x - this.x,\r\n        y: point.y - this.y\r\n      }\r\n      return false\r\n    } else if (isInWindow) {\r\n      this.mousedownInWindow(point)\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n  onMouseup (point) {\r\n    this.isDrag = false\r\n  }\r\n  onMousemove (point) {\r\n    if (this.isDrag) {\r\n      this.x = point.x - this.dragPoint.x\r\n      this.y = point.y - this.dragPoint.y\r\n    }\r\n  }\r\n  renderWindow (app, renderArea) {\r\n    // empty for subclass implements\r\n  }\r\n  mousedownInWindow (point) {\r\n    // empty for subclass implements\r\n  }\r\n  render (app, deltaPoint = {x: 0, y: 0}) {\r\n    let renderArea = this.renderArea\r\n    if (this.noExpendBtn) {\r\n      this.renderNoExpend(app, deltaPoint)\r\n      this.renderWindow(app, deltaPoint)\r\n    } else if (this.isExpend) {\r\n      this.renderExpend(app, deltaPoint)\r\n      this.renderWindow(app, deltaPoint)\r\n    } else {\r\n      this.renderClose(app, deltaPoint)\r\n    }\r\n  }\r\n  renderNoExpend (app, deltaPoint) {\r\n    let x = this.x + deltaPoint.x\r\n    let y = this.y + deltaPoint.y\r\n    let btnSize = defaults.btnSize\r\n    app.layer\r\n      .fillStyle(this.backgroundColor)\r\n      .fillRect(x, y, this.width, this.height)\r\n      .lineWidth(defaults.strokeWidth)\r\n      .strokeStyle(this.strokeColor)\r\n      .strokeRect(x, y, this.width, this.height)\r\n  }\r\n  renderExpend (app, deltaPoint) {\r\n    let x = this.x + deltaPoint.x\r\n    let y = this.y + deltaPoint.y\r\n    let btnSize = defaults.btnSize\r\n    app.layer\r\n      .fillStyle(this.backgroundColor)\r\n      .fillRect(x, y, this.width, this.height)\r\n      .fillStyle(this.barColor)\r\n      .fillRect(x, y, this.width, btnSize)\r\n      .fillStyle(this.expendBtnColor)\r\n      .fillRect(x, y, btnSize, btnSize)\r\n      .lineWidth(defaults.strokeWidth)\r\n      .strokeStyle(this.strokeColor)\r\n      .strokeRect(x, y, this.width, this.height)\r\n      .strokeRect(x, y, this.width, btnSize)\r\n      .strokeLine(x, y + btnSize / 2, x + btnSize, y + btnSize / 2)\r\n      .strokeRect(x, y, btnSize, btnSize)\r\n  }\r\n  renderClose (app, deltaPoint) {\r\n    let x = this.x + deltaPoint.x\r\n    let y = this.y + deltaPoint.y\r\n    let btnSize = defaults.btnSize\r\n    app.layer\r\n      .fillStyle(this.expendBtnColor)\r\n      .fillRect(x, y, btnSize, btnSize)\r\n      .lineWidth(defaults.strokeWidth)\r\n      .strokeStyle(this.strokeColor)\r\n      .strokeLine(x + btnSize / 2, y, x + btnSize / 2, y + btnSize)\r\n      .strokeLine(x, y + btnSize / 2, x + btnSize, y + btnSize / 2)\r\n      .strokeRect(x, y, btnSize, btnSize)\r\n  }\r\n}\r\n\r\nmodule.exports = Window\r\n\n\n//# sourceURL=webpack:///./src/gui/Window.js?");

/***/ }),

/***/ "./src/levels/level1.json":
/*!********************************!*\
  !*** ./src/levels/level1.json ***!
  \********************************/
/*! exports provided: level, map, enemy_path, round, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"level\\\":1,\\\"map\\\":[[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1],[0,2,2,2,2,2,2,2,2,1,1],[1,1,1,1,1,1,1,1,2,1,1],[1,1,1,1,1,1,1,1,2,1,1],[1,1,1,1,1,1,1,1,2,1,1],[1,1,1,1,8,8,8,1,2,1,1],[1,1,1,1,8,8,8,8,2,1,1],[1,1,1,1,1,8,8,1,2,1,1],[1,2,2,2,2,2,2,2,2,1,1],[1,2,1,1,1,1,1,1,1,1,1],[1,2,1,1,1,1,1,1,1,1,1],[1,2,1,1,1,1,1,1,1,1,1],[1,2,2,2,2,2,2,2,2,2,9],[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1]],\\\"enemy_path\\\":[{\\\"x\\\":192,\\\"y\\\":0},{\\\"x\\\":192,\\\"y\\\":512},{\\\"x\\\":640,\\\"y\\\":512},{\\\"x\\\":640,\\\"y\\\":64},{\\\"x\\\":896,\\\"y\\\":64},{\\\"x\\\":896,\\\"y\\\":640}],\\\"round\\\":[{\\\"enemy\\\":{\\\"type\\\":0,\\\"hp\\\":10},\\\"count\\\":10},{\\\"enemy\\\":{\\\"type\\\":0,\\\"hp\\\":100,\\\"mass\\\":0.4},\\\"count\\\":10},{\\\"enemy\\\":{\\\"type\\\":0,\\\"hp\\\":5000,\\\"mass\\\":0.9,\\\"scale\\\":1.5,\\\"reward\\\":1000},\\\"count\\\":1},{\\\"enemy\\\":{\\\"type\\\":0,\\\"hp\\\":10000,\\\"mass\\\":0.5,\\\"scale\\\":1.5,\\\"reward\\\":200},\\\"count\\\":10},{\\\"enemy\\\":{\\\"type\\\":1,\\\"hp\\\":10000,\\\"mass\\\":0.2,\\\"scale\\\":0.7,\\\"reward\\\":0},\\\"count\\\":2},{\\\"enemy\\\":{\\\"type\\\":1,\\\"hp\\\":5000,\\\"defence\\\":30,\\\"mass\\\":0.5,\\\"scale\\\":1,\\\"reward\\\":1000},\\\"count\\\":10},{\\\"enemy\\\":{\\\"type\\\":1,\\\"hp\\\":100000,\\\"defence\\\":200,\\\"mass\\\":1,\\\"scale\\\":2,\\\"reward\\\":1000},\\\"count\\\":1}]}\");\n\n//# sourceURL=webpack:///./src/levels/level1.json?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ENGINE = __webpack_require__(/*! ./engine */ \"./src/engine.js\")\r\n\r\nvar app = new PLAYGROUND.Application({\r\n\r\n  paths: {\r\n    images: './images/',\r\n    atlases: './atlases/',\r\n    rewriteURL: {\r\n      background: '/images/background.png'\r\n    }\r\n  },\r\n\r\n  create: function () {\r\n    this.loadImage([\r\n      '<background>',\r\n      'fire_bolt',\r\n      'effect/bolt03',\r\n      // floor\r\n      'dc-dngn/floor/grass/grass1',\r\n      'dc-dngn/floor/grass/grass_full',\r\n      'dc-dngn/gateways/dngn_portal',\r\n      'dc-dngn/dngn_trap_teleport',\r\n      'dc-dngn/water/dngn_shoals_shallow_water1',\r\n      // tower\r\n      'dc-dngn/altars/dngn_altar_makhleb_flame1',\r\n      'dc-dngn/altars/dngn_altar_sif_muna',\r\n      'fire_bolt',\r\n      'cursor'\r\n    ])\r\n    this.loadAtlases(['sorlosheet', 'sorlosheet_super'])\r\n  },\r\n\r\n  ready: function () {\r\n    this.setState(ENGINE.Game)\r\n  },\r\n\r\n  mousedown: function (data) {\r\n  },\r\n\r\n  scale: 0.5\r\n\r\n})\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });